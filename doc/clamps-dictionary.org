#+TITLE: Clamps Dictionary
#+AUTHOR: Orm Finnendahl
#+LANGUAGE: en
#+startup: entitiespretty
#+OPTIONS: html5-fancy:t
#+OPTIONS: num:nil
#+OPTIONS: toc:2 h:3 html-multipage-join-empty-bodies:t
#+OPTIONS: html-multipage-split:2
#+OPTIONS: html-multipage-toc-to-top:t
#+OPTIONS: html-multipage-export-directory:html/clamps-doc/clamps-dict
#+OPTIONS: html-multipage-open:nil
#+OPTIONS: html-multipage-numbered-filenames:nil
#+OPTIONS: html-preamble:"<a class=\"top-menu\" href=\"../overview/index.html\">Overview</a>\n<a class=\"top-menu\" href=\"../clamps/index.html\">Clamps Packages</a>\n<a class=\"top-menu\" href=\"../cm-dict/index.html\">CM Dictionary</a>\n<a class=\"top-menu top-menu-active\" href=\"./index.html\">Clamps Dictionary</a>\n<a class=\"top-menu\" href=\"../fomus/index.html\">Fomus</a>\n"
#+OPTIONS: html-toc-title:"Index"
#+OPTIONS: html-multipage-include-default-style:nil
#+HTML_DOCTYPE: xhtml5
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/clamps-dictionary.css" />
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/themes.css" />
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../css/htmlize.css" />
#+HTML_HEAD: <link href="./pagefind/pagefind-ui.css" rel="stylesheet">
#+HTML_HEAD: <script src="./pagefind/pagefind-ui.js"></script>
#+HTML_HEAD: <script src="../js/clamps-doc.js"></script>
# #+SETUPFILE: clamps-dict.setup
#+BEGIN_SRC emacs-lisp :exports results :results: none
  (load (format "%s%s" (file-name-directory (buffer-file-name))
                    "../extra/elisp/clamps-lookup.el"))
  (load (format "%s%s" (file-name-directory (buffer-file-name))
                    "../extra/elisp/clamps-overview-lookup.el"))
  (defun extract-link (string)
  (if (= (aref (string-trim string) 0) 42)
      (replace-regexp-in-string "\\*​\\(.+\\)​\\*" "#\\1" string)
      string))
  (defun export-dict-to-clamps (s backend info)
    (let ((filename (buffer-file-name)))
      (with-temp-buffer
        (insert
         (format "(load \"%s%s\")\n" (file-name-directory filename)
                 "../extra/elisp/cm-dict.el"))
        (insert "(mapcar
   (lambda (entry)
     (let ((symbol (intern (car entry)
  			 ,*common-music-symbols*)))
       (if (boundp symbol)
  	 (push (cadr entry) (symbol-value symbol))
         (set symbol (cdr entry)))))
   '(\n")
        (mapcar
         (lambda (entry)
           (insert
            (format "   (\"%s\" \"clamps-dict/%s\")\n"
                    (extract-link (org-html-element-title (car entry)))
                    (plist-get (cdr entry) :href))))
         (cl-remove-if
          (lambda (x) (= 1 (plist-get (cdr x) :relative-level)))
          (plist-get info :multipage-toc-lookup)))
        (insert "))\n")
        (write-region (point-min) (point-max) "../extra/elisp/clamps-dict.el"))
      (load (format "%s%s" (file-name-directory (buffer-file-name))
                    "../extra/elisp/clamps-dict.el"))
      s))
  (setq gc-cons-threshold 102400000)
  (setq max-lisp-eval-depth 10000)
#+END_SRC
#+BIND: org-export-filter-multipage-functions (export-dict-to-clamps)
#+BIND: org-html-htmlize-output-type 'css
# \[\[\([^\[]+\)\]\] → [[\1][\1]]
# C-x 8 RET 200b RET C-x 8 0

* Overview
** Notation and Usage
   The Clamps Dictionary has been inspired by the [[../cm-dict/index.html][CM Dictionary]], which
   was an original part of Common Music 2. Rather than interfering
   with the original, the additions of the Clamps package have been
   separated into this [[./index.html][Clamps Dictionary]]. Both dictionaries are
   accessed by the same keyboard shortcut /<C-c C-d c>/, automatically
   integrated into the Clamps system using the standard [[overview:Installation][Installation]].

   The Notation of the Clamps Dictionary is simpler than the Notation
   used in the CM Dictionary. Function and Macro definitions use the
   definition syntax of the function or macro with the initial /defun/
   or /defmacro/ removed.

   Names of argumens in the /Arguments/ section of entries are printed
   in =red= and emphasized words appear in /green/.
* A
** abs-path
   Function
   #+BEGIN_SRC lisp
     (abs-path sample-path sfz-file-path)
   #+END_SRC
** add-buffer
   Function
   #+BEGIN_SRC lisp
     (add-buffer buf)
   #+END_SRC
   add buffer to registry.
** add-dsp
   Function
   #+BEGIN_SRC lisp
     (add-dsp dsp id &rest args)
   #+END_SRC
   Add a new instance of /dsp/ with id /id/ to the registry, optionally
   supplying the dsp creation with initialization arguments /args/.
*** Arguments
    =dsp= -- The dsp type to add

    =id= -- Keyword or Symbol to identify the registered dsp.

    =args= -- Optional initialization arguments accepted by the used dsp
    class.


*** See also
    - [[find-dsp][find-dsp]]
    - [[list-dsps][list-dsps]]
    - [[remove-dsp][remove-dsp]]
** add-elements
   Generic Function
   #+BEGIN_SRC lisp
     (add-elements container-obj &rest elems)
   #+END_SRC
   add elements supplied either as svg-objects or as list(s) of svg-objects
** add-midi-controller
   Function
   #+BEGIN_SRC lisp
     (add-midi-controller class #:id &rest args)
   #+END_SRC
   Register a MIDI controller of class /class/ with ID /id/ and optional
   initialization argumens /args/.
*** Arguments
    =class= -- The class of the midi controller to add.

    =id= -- Keyword or Symbol used as ID of the instance.

    =args= -- Initialization arguments appropriate for the class.


*** See also
    - [[find-controller][find-controller]]
    - [[remove-midi-controller][remove-midi-controller]]
    - [[remove-all-midi-controllers][remove-all-midi-controllers]]
** add-sfz-preset
   Function
   #+BEGIN_SRC lisp
     (add-sfz-preset preset file)
   #+END_SRC
   Register the association between a preset name and its corresponding sfz
   file.
*** Arguments
    =preset= -- A keyword or symbol to name the preset

    =file= -- A string or path to the associated sfz file. If the file
    path is relative, it will be searched recursively in all paths of /
    cl-user::*​​sfz-file-path​​*/.


*** Note
    This function only stores the association between the preset
    name and its sfz file. Loading of its samples into memory is done
    implicitely when the preset is used by a playing function like
    [[play-sfz][#'play-sfz]] or by using [[ensure-sfz-preset][#'ensure-sfz-preset]] or its synonym
    [[get-sfz-preset][#'get-sfz-preset]].
    
*** See also
    - [[ensure-sfz-preset][ensure-sfz-preset]]
    - [[get-sfz-preset][get-sfz-preset]]
    - [[sfz][sfz]]
    - [[sfz-preset-loaded?][sfz-preset-loaded?]]
** all-permutations
   Function
   #+BEGIN_SRC lisp
     (all-permutations list &key (test #'eql) (max-length 10))
   #+END_SRC
   Get all permutations of /list/. Make sure to supply a /test/
   function in case the elements can't be compared with #'eql, otherwise
   the function will blow the stack. /max-length/ is the maximum length
   of /list/ accepted. This serves as a safety measure to avoid making
   the lisp process unresponsive due to an excessive number of
   permutations.
*** Arguments
    =list= -- List of elements to be permuted.

    =:test= -- Function to test for equality of elements in list.

    =:max-length= -- maximum length of list accepted.


*** Examples
    #+BEGIN_SRC lisp
      (all-permutations (range 4))
      ;; => ((0 1 2 3) (0 1 3 2) (0 2 1 3) (0 2 3 1) (0 3 1 2) (0 3 2 1) (1 0 2 3)
      ;; (1 0 3 2) (1 2 0 3) (1 2 3 0) (1 3 0 2) (1 3 2 0) (2 0 1 3) (2 0 3 1)
      ;; (2 1 0 3) (2 1 3 0) (2 3 0 1) (2 3 1 0) (3 0 1 2) (3 0 2 1) (3 1 0 2)
      ;; (3 1 2 0) (3 2 0 1) (3 2 1 0))
      
      (all-permutations (range 20))
      ;;
      ;; => Error: list to be permuted exceeds maximum length.
    #+END_SRC
** amp->db
   Function
   #+BEGIN_SRC lisp
     (amp->db amp)
   #+END_SRC
   Return dB value of linear amplitude /amp/. An amplitude of 0 returns a
   dB value of -100.
*** Arguments
    =amp= -- Positive Integer denoting amplitude.


*** Example
    #+BEGIN_SRC lisp
      (amp->db 1) ; => 0.0
      (amp->db 0) ;= -100
    #+END_SRC
** amp->db-slider
   Function
   #+BEGIN_SRC lisp
     (amp->db-slider amp &key (min -40) (max 12))
   #+END_SRC
** array-slice
   Function
   #+BEGIN_SRC lisp
     (array-slice arr row-idx)
   #+END_SRC
   Return the row with index /row-idx/ of a 2-dimensional array as
   1-dimensional array, sharing the same data structure by utilizing
   Common Lisp's displaced array functionality.
** ats->browser
   Function
   #+BEGIN_SRC lisp
     (ats->browser ats-snd &key (reload t))
   #+END_SRC
   Display the ats struct /ats-snd/ graphically in the interactive ATS
   Player located at /<clamps-base-url>/ats-display/ in the Gui.
*** Arguments
    =ats-snd= -- The ats struct to display.


*** See also
    - [[clamps-base-url][clamps-base-url]]
** audio-bus
   Generic Function
   #+BEGIN_SRC lisp
     (audio-bus object)
   #+END_SRC
   automatically generated reader method
* B
** bang-object
   Class

** bind-ref-to-attr
   Generic Function
   #+BEGIN_SRC lisp
     (bind-ref-to-attr refvar attr &optional map)
   #+END_SRC
** bind-refs-to-attrs
   Function
   #+BEGIN_SRC lisp
     (bind-refs-to-attrs &rest refs-and-attrs)
   #+END_SRC
** *​bindings​*
   :PROPERTIES:
   :CUSTOM_ID: bindings
   :END:
   Variable

** buchla-scale
   Function
   #+BEGIN_SRC lisp
     (buchla-scale curr old target &key (max 127))
   #+END_SRC
   Set the <target> fader by interpolating between 0 and <max>, using
   the <curr> and <old> values of a source fader.
   
   The function serves the purpose of avoiding jumps when working with
   non motorized hardware faders: If the value of the software target
   of the hardware fader has changed (e.g. by a preset or some program
   logic) without the hardware fader being updated, moving the
   hardware fader will not cause a jump in the target:
   
   If the hardware fader moves up (> curr old), the remaining space
   above the fader will interpolate the target software fader between
   its current value and the maximum value, if it moves down (< curr
   old), the software target will be interpolated between the current
   value and 0 using the remaining space below the hardware fader.
** buffer-id
   Function
   #+BEGIN_SRC lisp
     (buffer-id buffer)
   #+END_SRC
   get index of buffer from registry.
** buffer-loop-play*
   Function
   #+BEGIN_SRC lisp
     (buffer-loop-play* buffer rate start-pos loopstart loopend &optional ugen-node)
   #+END_SRC
** buffer-stretch-play
   Function
   #+BEGIN_SRC lisp
     (buffer-stretch-play buffer rate wwidth start end stretch)
   #+END_SRC
** bus-name
   Generic Function
   #+BEGIN_SRC lisp
     (bus-name object)
   #+END_SRC
   automatically generated reader method
* C
** calcsndbytes
   Function
   #+BEGIN_SRC lisp
     (calcsndbytes hr min sec &key (samplerate 44100) (bytes-per-sample 4))
   #+END_SRC
   Return the number of bytes (not samples!) from /hr/, /min/ and
   /sec/. Samplerate and the number of bytes per sample can be supplied
   using the /samplerate/ and /bytes-per-sample/ keywords..
*** Arguments
    =hr= -- Number of hours.

    =min= -- Number of minutes.

    =hr= -- Number of seconds.

    =samplerate= -- Number of samples per second.

    =bytes-per-sample= -- Number of bytes per sample.


*** Example
    #+BEGIN_SRC lisp
      (calcsndbytes 0 1 10) ; => 12348000
    #+END_SRC
** call/collecting
   Function
   #+BEGIN_SRC lisp
     (call/collecting f n &optional (tail '()))
   #+END_SRC
   Call function /f/ /n/ times, with idx [0..n-1] as argument,
   collecting its results. Return results with tail appended.
*** Arguments
    =f= -- Function of one argument (an integer in the range [0..n])

    =n= -- Positive integer

    =tail= -- A list collected into by prepending to it


*** Examples
    #+BEGIN_SRC lisp
      (call/collecting (lambda (x) (* x x)) 4 '()) ; => (0 1 4 9)
      
      (call/collecting (lambda (x) (1+ x)) 4 '(hallo)) ; => (1 2 3 4 hallo)
    #+END_SRC
*** See also
    - [[v-collect][v-collect]]
** case-ext
   Macro
   #+BEGIN_SRC lisp
     (case-ext keyform test &rest body)
   #+END_SRC
   case with compare function as second element.
** ccin
   Function
   #+BEGIN_SRC lisp
     (ccin ccnum &optional (channel *global-midi-channel*))
   #+END_SRC
   Return the last received MIDI CC value of controller number /ccnum/
   at MIDI channel /channel/. Setfable.
*** Arguments
    =ccnum= -- Integer in the range [0..127] indicating the Controller
    Number.

    =channel= -- Integer in the range [0..15] indicating the MIDI
    channel.


** cd
   Function
   #+BEGIN_SRC lisp
     (cd &optional (dirarg (user-homedir-pathname)))
   #+END_SRC
   Change the current working directory to /dirarg/ or to $HOME if dirarg
   is not supplied.
*** Arguments
    =dirarg= -- String or Pathname.


*** See also
    - [[pwd][pwd]]
** clamps
   Function
   #+BEGIN_SRC lisp
     (clamps &rest args)
   #+END_SRC
   Start Clamps including the gui.
   
   Besides starting the Gui the function also:
   
   - Starts the osc responder for Inkscape.
   - Starts the realtime engine calling #'rts.
   - Creates groups and buses for incudine dsps (see the
   Chapter [[clamps:General Incudine Setup][General Incudine Setup]].
   - Starts the documentation acceptor for the searchable online doc
   at /http://localhost:8282/overview/index.html/.
   
   In the given path the following directories
   will be created:
   
   - /<clamps-gui-root>/www//
   - /<clamps-gui-root>/www/svg/
   
   The latter is the file path for svg files used in the
   /<clamps-base-url>/svg-display/ page of the Gui.
   
   Any files which need to be accessible by the Gui have to be put
   into the /<clamps-gui-root>/www// subdirectory with their filenames
   relative to this directory.
*** Arguments
    =gui-root= -- String or Pathname indicating where to put the /www/
    subfolder for files accessible by the gui (nicknamed /<clamps-gui-
    root>/).

    =open= -- Boolean indicating whether to open the /<clamps-base-url>/
    in a browser window after starting the gui.


*** See also
    - [[clamps-base-url][clamps-base-url]]
    - [[clamps-restart-gui][clamps-restart-gui]]
    - [[clamps-gui-root][clamps-gui-root]]
** clamps-base-url
   Function
   #+BEGIN_SRC lisp
     (clamps-base-url)
   #+END_SRC
   Return the base url to access the Clamps Gui (nicknamed
   /<clamps-base-url>/ in this dictionary).
   
   Its default location is http://localhost:54619.
   
   /<clamps-base-url>/ on the browser side is corresponding to the
   path /<clamps-gui-root>/, so an address named
   /<clamps-base-url>/<file>/ will load the file located at
   /<clamps-gui-root>/<file>/ as HTML into the browser window.
   
   The location for the [[svg->browser][SVG Player Gui]] is at
   /<clamps-base-url>/svg-display/ which translates to the URL
   
   http://localhost:54619/svg-display
*** See also
    - [[clamps][clamps]]
    - [[clamps-restart-gui][clamps-restart-gui]]
    - [[clamps-gui-root][clamps-gui-root]]
    - [[gui][gui]]
    - [[meters][meters]]
** clamps-gui-root
   Function
   #+BEGIN_SRC lisp
     (clamps-gui-root)
   #+END_SRC
   Return the pathname of the Gui root directory. It is nicknamed
   /<clamps-gui-root>/ throughout this dictionary.
   
   /<clamps-gui-root>/ is the path corresponding to
   /<clamps-base-url>/ on the browser side, so any file named /<file>/
   put into the /<clamps-gui-root>/ directory can be accessed in the
   browser at the address /<clamps-base-url>/<file>/.
*** See also
    - [[clamps][clamps]]
    - [[clamps-base-url][clamps-base-url]]
    - [[clamps-restart-gui][clamps-restart-gui]]
** clamps-restart-gui
   Function
   #+BEGIN_SRC lisp
     (clamps-restart-gui gui-root &key (open t) (port 54619))
   #+END_SRC
   Reset the root directory of the Gui to /gui-root/www/, optionally
   opening the Gui in a browser window.
*** Arguments
    =gui-root= -- ist the path where to put the /www/ subfolder for
    files accessible by the gui (nicknamed /<clamps-gui-root>/
    throughout this dictionary).

    =:open= -- is a flag indicating whether to open [[clamps-base-url]
    [clamps-base-url]] in a browser window after starting the gui.  In
    the given path the following directories will be created:

    - /<clamps-gui-root>/www//
    - /<clamps-gui-root>/www/svg//  file path for svg files used in the /
    svg-display/ page of the Gui.  Any files which need to be accessible
    by the Gui have to be put into the /<clamps-gui-root>/www//
    subdirectory with their filenames relative to this directory.

*** See also
    - [[clamps][clamps]]
    - [[clamps-base-url][clamps-base-url]]
    - [[clamps-gui-root][clamps-gui-root]]
** clamps-start
   Function
   #+BEGIN_SRC lisp
     (clamps-start &key (gui-root "/tmp") (qsynth nil) (open-gui nil))
   #+END_SRC
   Start clamps, optionally starting qsynth (Linux only) and opening
   the gui in a browser. This function gets called by [[clamps][clamps]] and
   should normally not be called by the user.
*** Arguments
    =gui-root= -- The root path of the gui

    =qsynth= -- Boolean indicating whether to start the qsynth softsynth
    (Linux only).

    =open-gui= -- Boolean indicating whether to open the gui in a
    Browser window.


*** See also
    - [[clamps-gui-root][clamps-gui-root]]
** clear-bindings
   Function
   #+BEGIN_SRC lisp
     (clear-bindings)
   #+END_SRC
** clear-dependencies
   Function
   #+BEGIN_SRC lisp
     (clear-dependencies co cb)
   #+END_SRC
   clear all dependencies of a computed ref object.
** clip
   Function
   #+BEGIN_SRC lisp
     (clip val min max)
   #+END_SRC
   Clip val into the range [min..max].
*** Arguments
    =val= -- Number to be clipped.

    =min= -- Number denoting minimum bound.

    =min= -- Number denoting maximum bound.


*** Example
    #+BEGIN_SRC lisp
      (clip -10 0 3) ; => 0
      
      (clip 10 0 3) ; => 3
      
      (clip 1.73 0 3) ; => 1.73
    #+END_SRC
** collect-pool
   Function
   #+BEGIN_SRC lisp
     (collect-pool &rest keys)
   #+END_SRC
** combinations
   Function
   #+BEGIN_SRC lisp
     (combinations seq &optional (n 2))
   #+END_SRC
   Get all n combinations of seq.
** construct-plot-command
   Function
   #+BEGIN_SRC lisp
     (construct-plot-command &key region (grid t) (header *gnuplot-header*) (options *gnuplot-options*) &allow-other-keys)
   #+END_SRC
   Helper function to construct the gnuplot command with a given
   header, options and a grid flag.
** copy-instance
   Generic Function
   #+BEGIN_SRC lisp
     (copy-instance object &rest initargs &key &allow-other-keys)
   #+END_SRC
** copy-ref
   Function
   #+BEGIN_SRC lisp
     (copy-ref ref)
   #+END_SRC
** count-elements
   Function
   #+BEGIN_SRC lisp
     (count-elements seq &key (test #'eql) (key #'identity) (sort t))
   #+END_SRC
   Count the number of occurences of all mutually equal elems in
   /seq/ extracted from its items according to the /key/ function and
   satisfying the /test/ function as predicate. Return the results as
   list with sublists of the form (elem count) for each elem, optionally
   sorted according to the setting of /sort/.
*** Arguments
    =seq= -- A Common Lisp Sequence.

    =:test= -- Function accepted as test function by #'make-hash-table.

    =:key= -- Function to extract the key to compare from each element.

    =:sort= -- Boolean indicationg whether and how to sort the results.
    Possible Values are:

    - /:from-end/
    - /t/
    - /nil/

   If /:sort/ is /nil/, result returns the items in the order of their
   first occurence, if /:sort/ is /:from-end/, they are returned in
   reverse order of occurence, if /:sort/ is /t/, they are either sorted
   by their value, if all elems are numbers or by the number of occurences
   otherwise.
*** Examples
    #+BEGIN_SRC lisp
      (count-elements '(1 3 2 6 5 4 3 8 1 3 5 2 4 3 6 5 3 3 4 1))
      ;; => ((1 3) (2 2) (3 6) (4 3) (5 3) (6 2) (8 1))
      
      (count-elements '(1 3 2 6 5 4 3 8 1 3 5 2 4 3 6 5 3 3 4 1) :sort :from-end)
      ;; => ((8 1) (4 3) (5 3) (6 2) (2 2) (3 6) (1 3))
      
      (count-elements '(1 3 2 6 5 4 3 8 1 3 5 2 4 3 6 5 3 3 4 1) :sort t)
      ;; => ((1 3) (2 2) (3 6) (4 3) (5 3) (6 2) (8 1))
      
      (count-elements '(a b a d e c d a e d e b d f d e) :sort t)
      ;; => ((d 5) (e 4) (a 3) (b 2) (f 1) (c 1))
      
      (count-elements '((a 10) (b 11) (a 12) (d 13)) :key #'first :sort t)
      ;; => ((a 2) (d 1) (b 1))
    #+END_SRC
** create-collection
   Function
   #+BEGIN_SRC lisp
     (create-collection parent width)
   #+END_SRC
** create-grid
   Function
   #+BEGIN_SRC lisp
     (create-grid parent class width)
   #+END_SRC
** create-hide-button
   Function
   #+BEGIN_SRC lisp
     (create-hide-button parent element-to-hide &key label (background '("transparent" "orange")) color flash-time values css (val 1) auto-place)
   #+END_SRC
** create-o-bang
   Function
   #+BEGIN_SRC lisp
     (create-o-bang parent bindings &key width height label (background '("transparent" "orange")) color flash-time css flash)
   #+END_SRC
** create-o-knob
   Function
   #+BEGIN_SRC lisp
     (create-o-knob parent bindings &key (unit "") (precision 2) min max width height step css)
   #+END_SRC
** create-o-multislider
   Function
   #+BEGIN_SRC lisp
     (create-o-multislider parent bindings &key (direction :up) (value 0) (min 0) (max 1) width height label background colors (thumb-color "transparent") (mapping :lin) (clip-zero nil))
   #+END_SRC
** create-o-numbox
   Function
   #+BEGIN_SRC lisp
     (create-o-numbox parent bindings &key min max width height (precision 2) css)
   #+END_SRC
** create-o-radio
   Function
   #+BEGIN_SRC lisp
     (create-o-radio parent bindings &key labels label width height (background '(("transparent" ("orange")))) color flash-time values (num 8) (direction :right) css)
   #+END_SRC
** create-o-scope
   Function
   #+BEGIN_SRC lisp
     (create-o-scope parent bindings &key width height css buffer)
   #+END_SRC
** create-o-slider
   Function
   #+BEGIN_SRC lisp
     (create-o-slider parent bindings &key (direction :up) (min 0) (max 1) label background thumb-color bar-color (mapping :lin) (clip-zero nil) (width "1em") (height "8em") padding css)
   #+END_SRC
** create-o-svg
   Function
   #+BEGIN_SRC lisp
     (create-o-svg parent bindings &key svg padding css (cursor-pos 0) (shift-x 0) (shift-y 0) (background "#fff") (scale 1) (inverse 0))
   #+END_SRC
** create-o-toggle
   Function
   #+BEGIN_SRC lisp
     (create-o-toggle parent bindings &key width height label (background '("transparent" "orange")) color flash-time values css)
   #+END_SRC
** create-o-vumeter
   Function
   #+BEGIN_SRC lisp
     (create-o-vumeter parent bindings &key (direction :up) (type :led) (mapping :db-lin) (width "1em") (height "8em") padding css)
   #+END_SRC
** ct->fr
   Function
   #+BEGIN_SRC lisp
     (ct->fr ct)
   #+END_SRC
   Return the frequency ratio of the Midicents interval /ct/.
*** Arguments
    =ct= -- The interval in Midicents.


*** Examples
    #+BEGIN_SRC lisp
      (ct->fr 12) ;; => 2
      
      (ct->fr 1) ;; => 1.0594631
      
      (ct->fr 7) ;; => 1.4983071
      
      (ct->fr -12) ;; => 1/2
      
      (mapcar #'ct->fr (range 13))
      ;;  => (1 1.0594631 1.122462 1.1892071 1.2599211 1.3348398 1.4142135 1.4983071
      ;;      1.587401 1.6817929 1.7817974 1.8877486 2)
    #+END_SRC
*** See also
    - [[fr->ct][fr->ct]]
** cuda-dsp
   Class

   Superclass for dsp objects of the dsp infrastructure
   of /clog-dsp-widgets/ in Clamps. An object derived from this type will
   be created using the [[add-dsp][add-dsp]] function and its slots automatically
   filled on initialization.
   
   cuda-dsp accepts the following slot initializations:
   
   =id= -- The id used in the clamps dsp infrastructure.
   
   =nodes= -- The active Incudine nodes of a running instance.
   
   =node-group= -- The Incudine group of a running instance.
   
   =unwatch= -- List of unwatch functions used by the instance.
*** Note
    Except for the /unwatch/ slot, the user normally will not be dealing
    with the slots of a cuda-dsp instance directly except for inspection
    purposes. The slots are documented here mainly for clarity and
    insight.
    
*** See also
    - [[clamps:clog-dsp-widgets][clog-dsp-widgets]]
    - [[add-dsp][add-dsp]]
* D
** date-string
   Function
   #+BEGIN_SRC lisp
     (date-string)
   #+END_SRC
   Return a string of the current time in the format
     /"yyyy-mm-dd-hr-min-sec"/
** db->amp
   Function
   #+BEGIN_SRC lisp
     (db->amp db)
   #+END_SRC
   Return amp value of dB value /db/. The dB value is clipped below -100
   and returns the amplitude 0.
*** Arguments
    =amp= -- Positive Integer denoting amplitude.


*** Example
    #+BEGIN_SRC lisp
      (db->amp 0) ; => 1
      (db->amp -6) ; => 0.5011872
      (db->amp -100) ; => 0
    #+END_SRC
** db->db-slider
   Function
   #+BEGIN_SRC lisp
     (db->db-slider db &key (min -40) (max 12))
   #+END_SRC
** db-slider->amp
   Function
   #+BEGIN_SRC lisp
     (db-slider->amp x &key (min -40) (max 12))
   #+END_SRC
** db-slider->db
   Function
   #+BEGIN_SRC lisp
     (db-slider->db slider-val &key (min -40) (max 12))
   #+END_SRC
** def-params
   Macro
   #+BEGIN_SRC lisp
     (def-params &rest syms)
   #+END_SRC
** define-watch
   Generic Function
   #+BEGIN_SRC lisp
     (define-watch refvar attr new)
   #+END_SRC
** defparameter*
   Macro
   #+BEGIN_SRC lisp
     (defparameter* &rest pairs)
   #+END_SRC
   Form for the definition of multiple parameters. /Pairs/ are one or
   more elements, being the arguments of a single defparameter form.
*** Arguments
    =pairs= -- one or more elements, either a Symbol or a list of 1-3
    elements with a Symbol as first and a String as third element.


*** Examples
    #+BEGIN_SRC lisp
      (defparameter* *a* (*b*) (*c* 1) (*d* 1 "parameter d"))
      
      ;; The above form is the same as:
      
      (progn
        (defparameter *a* nil)
        (defparameter *b* nil)
        (defparameter *c* 1)
        (defparameter *d* "parameter d"))
    #+END_SRC
*** See also
    - [[defvar*][defvar*]]
** defvar*
   Macro
   #+BEGIN_SRC lisp
     (defvar* &rest pairs)
   #+END_SRC
   Form for the definition of multiple variable. /Pairs/ are one or
   more elements, being the arguments of a single defparameter form.
*** Arguments
    =pairs= -- one or more elements, either a Symbol or a list of 1-3
    elements with a Symbol as first and a String as third element.


*** Examples
    #+BEGIN_SRC lisp
      (defvar​* *​a​* (*​b​*) (*​c​* 1) (*​d​* 1 "variable d"))
      
      ;; The above form is the same as:
      
      (progn
        (defvar *a* nil)
        (defvar *b* nil)
        (defvar *c* 1)
        (defvar *d* "variable d"))
    #+END_SRC
*** See also
    - [[defparameter*][defparameter*]]
** delete-props
   Function
   #+BEGIN_SRC lisp
     (delete-props proplist &rest props)
   #+END_SRC
   Destructively remove props from property list /proplist/ and return
   it.
*** Arguments
    =proplist= -- Property list.

    =props= -- One or more properties to delete.


*** See also
    - [[do-proplist][do-proplist]]
    - [[do-proplist/collecting][do-proplist/collecting]]
    - [[get-prop][get-prop]]
    - [[get-props-list][get-props-list]]
    - [[map-proplist][map-proplist]]
    - [[with-props][with-props]]
** differentiate
   Function
   #+BEGIN_SRC lisp
     (differentiate list &key (modifier #'-) (start (first list)))
   #+END_SRC
   Return differences between subsequent elements of list.
*** Arguments
    =list= -- List to integrate

    =:modifier= -- Function to apply to all elements accumulationg the
    results.

    =:start= -- Number denoting the start value.


*** Examples
    #+BEGIN_SRC lisp
      (differentiate '(0 2 3 7 12)) ; => (0 2 1 4 5)
      
      (differentiate '(1 2 6 12 48) :modifier #'/) ; => (1 2 3 2 4)
      
      (differentiate (integrate '(17 2 4))) ; => (17 2 4)
    #+END_SRC
** do-proplist
   Macro
   #+BEGIN_SRC lisp
     (do-proplist (keysym valuesym) proplist &body body)
   #+END_SRC
   Like dolist but traversing a property list. All keys and values of
   /proplist/ are bound to the symbols /keysym/ and /valuesym/ in the
   lexical scope of /body/.
*** Arguments
    =keysym= -- Symbol bound to all keys of the property list.

    =valuesym= -- Symbol bound to all values of the property list.

    =proplist= -- Property list to be traversed.


*** Examples
    #+BEGIN_SRC lisp
      (do-proplist (key value) '(a 1 b 2 c 3 d 4)
        (format t "key: ~a, value: ~a~%" key value)) ;  => nil
      
      ;; Output in REPL:
      ;;
      ;; key: a, value: 1
      ;; key: b, value: 2
      ;; key: c, value: 3
      ;; key: d, value: 4
      
      (let ((proplist '(a 1 b 2 c 3 d 4)))
        (do-proplist (key value) proplist
          (setf (getf proplist key) (incf value 10)))
        proplist)
      ;; => (a 11 b 12 c 13 d 14)
    #+END_SRC
*** See also
    - [[delete-props][delete-props]]
    - [[do-proplist/collecting][do-proplist/collecting]]
    - [[get-prop][get-prop]]
    - [[get-props-list][get-props-list]]
    - [[map-proplist][map-proplist]]
    - [[with-props][with-props]]
** do-proplist/collecting
   Macro
   #+BEGIN_SRC lisp
     (do-proplist/collecting (keysym valuesym) proplist &body body)
   #+END_SRC
   Like do-proplist but collecting the result. All keys and values of
   /proplist/ are bound to the symbols /keysym/ and /valuesym/ in the
   lexical scope of /body/.
*** Arguments
    =keysym= -- Symbol bound to all keys of the property list.

    =valuesym= -- Symbol bound to all values of the property list.

    =proplist= -- Property list to be traversed.


*** Examples
    #+BEGIN_SRC lisp
      (do-proplist/collecting (key val) '(:a 2 :b 5 :c 4)
        (list key (1+ val)))
      ;; => ((:a 3) (:b 6) (:c 5))
    #+END_SRC
*** See also
    - [[delete-props][delete-props]]
    - [[do-proplist][do-proplist]]
    - [[get-prop][get-prop]]
    - [[get-props-list][get-props-list]]
    - [[map-proplist][map-proplist]]
    - [[with-props][with-props]]
** do-repeated
   Function
   #+BEGIN_SRC lisp
     (do-repeated n fn &rest args)
   #+END_SRC
   Recursively apply /fn/ to /args/ /n/ times.
*** Arguments
    =n= -- Integer number of repetitions.

    =fn= -- Function to apply.


*** Examples
    #+BEGIN_SRC lisp
      (do-repeated 4 (lambda (x) (* x 2)) 1) ; => 16
      
      (do-repeated 4 (lambda (x) (* x x)) 2)  ; => 65536
      
      (do-repeated 6 (lambda (list) (cons 1 list)) '()) ; => (1 1 1 1 1 1)
    #+END_SRC
*** See also
    - [[repeated][repeated]]
** dround
   Function
   #+BEGIN_SRC lisp
     (dround num &optional (prec 2))
   #+END_SRC
   Return a float of /num/ rounded to /prec/ decimal places.
*** Arguments
    =num= -- The number to round.

    =prec= -- Non Negative Integer denoting the number of decimal places.


*** Examples
    #+BEGIN_SRC lisp
      (dround 1/3) ; => 0.33
      
      (dround 1/3 5) ; => 0.33333
      
      (dround 1) ; => 1.0
    #+END_SRC
** dsp-id
   Generic Function
   #+BEGIN_SRC lisp
     (dsp-id object)
   #+END_SRC
   Return the id of dsp /object/. Read-only.
*** See also
    - [[cuda-dsp][cuda-dsp]]
** dsp-nodes
   Generic Function
   #+BEGIN_SRC lisp
     (dsp-nodes object)
   #+END_SRC
   Accessor for the Incudine nodes slot of dsp /object/.
*** See also
    - [[cuda-dsp][cuda-dsp]]
* E
** ensure-buffer
   Function
   #+BEGIN_SRC lisp
     (ensure-buffer file &key (path *sfile-path*))
   #+END_SRC
   load and register buffer from file if not loaded already. Return
   buffer.
** ensure-prop
   Macro
   #+BEGIN_SRC lisp
     (ensure-prop proplist prop default)
   #+END_SRC
   Ensure that the property /prop/ exists in /proplist/, otherwise set it
   to /default/. Return the value of prop.
*** Arguments
    =proplist= -- Property list.

    =prop= -- Property key to ensure.

    =default= -- The value property should get assigned to if not set.


*** Examples
    #+BEGIN_SRC lisp
      (defvar *proplist* '(:a 10 :b hello :c "world"))
      
      (ensure-prop *proplist* :d 5)
      ;; => 5
      
      *proplist* ; => (:d 5 :a 10 :b hello :c "world")
      
      ;; As property :a already exists, don't change it and return its
      ;; current value:
      
      (ensure-prop *proplist* :a 3)
      ;; => 10
      
      *proplist* ; => (:d 5 :a 10 :b hello :c "world")
    #+END_SRC
** ensure-sfz-preset
   Function
   #+BEGIN_SRC lisp
     (ensure-sfz-preset preset &key force (play-fn #'play-sfz-loop))
   #+END_SRC
   Load the sfz definition of /preset/ and all its samples into the
   system if it hasn't been loaded previously. If force is /t/, force
   reload. Optionally set a play function.
   
   The association between the preset name and its sfz file has to be
   established before using [[add-sfz-preset][add-sfz-preset]], otherwise a warning is
   issued and no file is loaded.
*** Arguments
    =preset= -- A keynum or symbol to serve as the name/id of the
    preset.

    =:force= -- A boolean indicating to force a reload even if the
    preset has been loaded before.

    =:play-fn= -- The play function to be used. Possible options are:

    - [[play-sfz-loop][#'play-sfz-loop]]
    - [[play-sfz-one-shot][#'play-sfz-one-shot]]

*** See also
    - [[add-sfz-preset][add-sfz-preset]]
    - [[ensure-sfz-preset][ensure-sfz-preset]]
    - [[load-sfz-preset][load-sfz-preset]]
    - [[remove-sfz-preset][remove-sfz-preset]]
    - [[sfz-preset-loaded?][sfz-preset-loaded?]]
** *​env1​*
   :PROPERTIES:
   :CUSTOM_ID: env1
   :END:
   Variable

   Incudine three point ASR envelope with attack time 0 and release time
   0.1 of the total duration.
*** Example
      #+BEGIN_SRC lisp
      (plot *env1*)
      ;; => nil
      #+END_SRC
      #+attr_html: :width 50%
      #+CAPTION: *​env1​* envelope
      [[./img/env1-plot.svg]]
** envelope*
   Function
   #+BEGIN_SRC lisp
     (envelope* env gate time-scale done-action &optional ugen-node)
   #+END_SRC
** every-nth
   Function
   #+BEGIN_SRC lisp
     (every-nth list n &key (offset 0))
   #+END_SRC
   Return a sublist of /list/ containing every element with an index
   being a multiple of /n/.
*** Arguments
    =list= -- Input list.

    =n= -- Positive integer indicating the index distance between
    elements.

    =:offset= -- Positive integer indicating offset into the input list.


*** Example
    #+BEGIN_SRC lisp
      (every-nth '(9 10 11 12 13 14 15 16 17 18 19 20) 3 :offset 1)
      ;; => (10 13 16 19)
    #+END_SRC
** exp-n
   Macro
   #+BEGIN_SRC lisp
     (exp-n val min max)
   #+END_SRC
   Return the reverse exponential interpolation for a value in the range
   /[min..max]/ as a normalized float value. /Min/ and /max/ have to be
   positive numbers.
*** Arguments
    =x= -- An input value in the range /[min..max]/ to be interpolated.

    =min= -- The minimum value.

    =max= -- The maximum value.


*** Examples
    #+BEGIN_SRC lisp
      (exp-n 1 1 100) ; => 0.0
      
      (exp-n 10 1 100) ; => 0.5
      
      (exp-n 100 1 100) ; => 1.0
    #+END_SRC
*** See also
    - [[lin-n][lin-n]]
    - [[m-exp][m-exp]]
    - [[m-lin][m-lin]]
    - [[n-exp][n-exp]]
    - [[n-exp-dev][n-exp-dev]]
    - [[n-lin][n-lin]]
    - [[n-lin-dev][n-lin-dev]]
** export-svg
   Function
   #+BEGIN_SRC lisp
     (export-svg svg-file)
   #+END_SRC
** export-svg-file
   Function
   #+BEGIN_SRC lisp
     (export-svg-file svg-file &key (fname "/tmp/test.svg" fname-supplied-p) (inverse nil) (showgrid t) (gridtype "4x4") width (zoom 1.4) (cx 350) (cy 360) (w-width 1920) (w-height 1080) (w-x 0) (w-y 0))
   #+END_SRC
* F
** faderfox-gui
   Function
   #+BEGIN_SRC lisp
     (faderfox-gui #:id gui-parent &key (chan 4))
   #+END_SRC
** faderfox-midi
   Class

** fibonacci
   Function
   #+BEGIN_SRC lisp
     (fibonacci n)
   #+END_SRC
   Calculate the /n/-th element of the Fibonacci series. The function is
   not recursive, but calculates the value directly, running in constant
   time.
*** Arguments
    =n= -- Non Negative Integer denoting the index of the Fibonacci
    series.


*** Example
    #+BEGIN_SRC lisp
      (mapcar #'fibonacci (range 12)) ; => (1 1 2 3 5 8 13 21 34 55 89 144)
    #+END_SRC
** file-string
   Function
   #+BEGIN_SRC lisp
     (file-string infile)
   #+END_SRC
** filter
   Function
   #+BEGIN_SRC lisp
     (filter pred seq)
   #+END_SRC
   Return a list of all elements of /seq/ satisfying /pred/.
*** Arguments
    =seq= -- A Common Lisp sequence

    =pred= -- Function of one element for filtering elements.


*** Example
    #+BEGIN_SRC lisp
      (filter (lambda (e) (< e 9)) '(3 1 12 17 5 4)) ; => (3 1 5 4)
    #+END_SRC
** find-buffer
   Function
   #+BEGIN_SRC lisp
     (find-buffer name)
   #+END_SRC
   find all buffers with a name being a full pathname or the
   pathname-name of <name>.
** find-controller
   Function
   #+BEGIN_SRC lisp
     (find-controller #:id)
   #+END_SRC
   Return MIDI controller instance with ID /id/.
*** Arguments
    =id= -- Keyword or Symbol used as ID of a midicontroller instance .


*** See also
    - [[add-midi-controller][add-midi-controller]]
    - [[remove-midi-controller][remove-midi-controller]]
    - [[remove-all-midi-controllers][remove-all-midi-controllers]]
** find-dsp
   Function
   #+BEGIN_SRC lisp
     (find-dsp id)
   #+END_SRC
   Find a running Incudine dsp registered with [[add-dsp][add-dsp]].
*** Arguments
    =id= -- Keyword or Symbol identifying the dsp.


*** See also
    - [[add-dsp][add-dsp]]
    - [[list-dsps][list-dsps]]
    - [[remove-dsp][remove-dsp]]
** firstn
   Function
   #+BEGIN_SRC lisp
     (firstn seq n)
   #+END_SRC
   Return the first /n/ elems of /seq/.
** flash
   Generic Function
   #+BEGIN_SRC lisp
     (flash clog-obj)
   #+END_SRC
** flatten
   Function
   #+BEGIN_SRC lisp
     (flatten form)
   #+END_SRC
   Remove all brackets except the outmost from /form/. Non-recursive,
   non-stack version from Rosetta Code.
*** Arguments
    =form= -- A Common Lisp form.


*** Examples
    #+BEGIN_SRC lisp
      (flatten '((a b) (((c d) (e f)) (g h)) (i k)))
      ;; -> (a b c d e f g h i k)
    #+END_SRC
*** See also
    - [[flatten-fn][flatten-fn]]
** flatten-fn
   Function
   #+BEGIN_SRC lisp
     (flatten-fn seq &key (test #'atom) (key #'identity))
   #+END_SRC
   Remove all brackets except the outmost in seq. Use test and key to
      determine where to stop removing brackets.
*** Examples
    #+BEGIN_SRC lisp
      (flatten-fn '((a b) (((c d) (e f)) (g h)) (i k)))
      ;; -> (a b c d e f g h i k)
      
      ;; keep one level of brackets:
      
      (flatten-fn '((a b) (((c d) (e f)) (g h)) (i k)) :key #'car)
      ;; -> ((a b) (c d) (e f) (g h) (i k))
    #+END_SRC
*** See also
    - [[flatten][flatten]]
** format-with-slots
   Macro
   #+BEGIN_SRC lisp
     (format-with-slots stream obj string &rest slots)
   #+END_SRC
** fr->ct
   Function
   #+BEGIN_SRC lisp
     (fr->ct fr)
   #+END_SRC
   Return the Midicents interval of the frequency ratio /fr/.
*** Arguments
    =fr= -- The frequency ratio of the interval.


*** Examples
    #+BEGIN_SRC lisp
      (fr->ct 2) ;; => 12.0
      
      (fr->ct 4/5) ;; => -3.863137
      
      (fr->ct 3/2) ;; => 7.01955
      
      (fr->ct 1/2) ;; => -12.0
      
      (mapcar #'fr->ct (range 1 17))
      ;; => (0.0 12.0 19.01955 24.0 27.863136 31.01955 33.68826 36.0 38.0391 39.863136
      ;;     41.51318 43.01955 44.405277 45.68826 46.882687 48.0)
    #+END_SRC
*** See also
    - [[ct->fr][ct->fr]]
** ftom
   Function
   #+BEGIN_SRC lisp
     (ftom f &key (tuning-base 440))
   #+END_SRC
* G
** get-buffer
   Function
   #+BEGIN_SRC lisp
     (get-buffer id)
   #+END_SRC
   get buffer from registry by index.
** get-dtime-fn
   Function
   #+BEGIN_SRC lisp
     (get-dtime-fn mina maxa minbfn maxbfn &key (distribution '((0 :weight 9 (1 :weight 3) 2 3 4))) (thresh 0.5))
   #+END_SRC
   return a function calculating a delta-time on each call. The
   distribution specifies a random distribution (using cm's weighting) to
   determine the number of dtimes returned between [mina..maxa] before
   returning a number between calling [minbfn..maxbfn] on x. A :thresh
   keyword determines a threshold for [minb..maxb], below which no
   [mina..maxa] values are returned.
** get-dtime-fn-no-x
   Function
   #+BEGIN_SRC lisp
     (get-dtime-fn-no-x mina maxa minb maxb &key (distribution '(1 1 1 1 2 3 4)))
   #+END_SRC
   return a function calculating a delta-time on each call. The
   distribution specifies a random distribution (using cm's weighting) to
   determine the number of dtimes returned between [mina..maxa] before
   returning a number between [minb..maxb].
** get-duplicates
   Function
   #+BEGIN_SRC lisp
     (get-duplicates list &key (test #'eql) (once nil))
   #+END_SRC
   Return all Elements of /list/ which occur more than once with respect
   to the /test/ predicate. If /once/ is non-nil, return each duplicate
   element only once.
*** Arguments
    =list= -- List being examined.

    =test= -- Function to determine equality of elements.

    =once= -- Boolean to determine if only one of the duplicate elements
    is returned.


*** Examples
    #+BEGIN_SRC lisp
      (get-duplicates '(0 1 3 2 4 3 9 3 1 3 4 2 3)) ; => (1 3 2 4 3 3 3)
      
      (get-duplicates '(0 1 3 2 4 3 9 3 1 3 4 2 3) :once t)  ; => (1 2 4 3)
    #+END_SRC
** get-keynum
   Function
   #+BEGIN_SRC lisp
     (get-keynum entry)
   #+END_SRC
** get-prop
   Function
   #+BEGIN_SRC lisp
     (get-prop proplist key &optional default)
   #+END_SRC
   Like getf but using #'equal for testing of the property key.
*** Arguments
    =proplist= -- Property list

    =key= -- Lisp Object ervong as key in property list.


*** Example
    #+BEGIN_SRC lisp
      (get-prop '("George" "Maciunas" "Simone" "de Beauvoir") "Simone") ; => "de Beauvoir"
    #+END_SRC
*** See also
    - [[delete-props][delete-props]]
    - [[do-proplist][do-proplist]]
    - [[do-proplist/collecting][do-proplist/collecting]]
    - [[get-props-list][get-props-list]]
    - [[map-proplist][map-proplist]]
    - [[with-props][with-props]]
** get-props-list
   Function
   #+BEGIN_SRC lisp
     (get-props-list proplist props &key (force-all nil))
   #+END_SRC
   Return a new property list containing /props/ and their values
   extracted from /proplist/. Properties not present in proplist are
   ignored. If /force-all/ is non-nil, also return properties not present
   in proplist with nil as value.
*** Arguments
    =proplist= -- Property list.

    =props= -- Properties to extract from proplist.

    =:force-all= -- Boolean to indicate if non-present props should get
    included in result.


*** Examples
    #+BEGIN_SRC lisp
      (get-props-list '(:a 1 :b 2 :c 3 :d "Foo") '(:d :a)) ; => (:d "Foo" :a 1)
      
      (get-props-list '(:a 1 :b 2 :c 3 :d "Foo") '(:a :e)) ; => (:a 1)
      
      (get-props-list '(:a 1 :b 2 :c 3 :d "Foo" :a 4) '(:a :e) :force-all t)  ; => (:a 1 :e nil)
    #+END_SRC
*** See also
    - [[delete-props][delete-props]]
    - [[do-proplist][do-proplist]]
    - [[do-proplist/collecting][do-proplist/collecting]]
    - [[get-prop][get-prop]]
    - [[map-proplist][map-proplist]]
    - [[with-props][with-props]]
** get-ref
   Function
   #+BEGIN_SRC lisp
     (get-ref controller ref-idx)
   #+END_SRC
   return the ref-object of the midi-controller <controller> given the
   <ref-idx> indexing into the cc-nums slot of the controller.
** get-sfz-preset
   Function
   #+BEGIN_SRC lisp
     (get-sfz-preset preset &key force (play-fn #'play-sfz-loop))
   #+END_SRC
   Load the sfz definition of /preset/ and all its samples into the
   system if it hasn't been loaded previously. If force is /t/, force
   reload. Optionally set a play function.
   
   The association between the preset name and its sfz file has to be
   established before using [[add-sfz-preset][add-sfz-preset]], otherwise a warning is
   issued and no file is loaded.
*** Arguments
    =preset= -- A keynum or symbol to serve as the name/id of the
    preset.

    =:force= -- A boolean indicating to force a reload even if the
    preset has been loaded before.

    =:play-fn= -- The play function to be used. Possible options are:

    - [[play-sfz-loop][#'play-sfz-loop]]
    - [[play-sfz-one-shot][#'play-sfz-one-shot]]

*** See also
    - [[add-sfz-preset][add-sfz-preset]]
    - [[ensure-sfz-preset][ensure-sfz-preset]]
    - [[load-sfz-preset][load-sfz-preset]]
    - [[remove-sfz-preset][remove-sfz-preset]]
    - [[sfz-preset-loaded?][sfz-preset-loaded?]]
** get-sndfile-path
   Function
   #+BEGIN_SRC lisp
     (get-sndfile-path fname path)
   #+END_SRC
** get-time
   Function
   #+BEGIN_SRC lisp
     (get-time secs &key (prec 2))
   #+END_SRC
   Convert a /secs/ representing seconds into a list of the form /(hr min
   secs)/.
*** Arguments
    =secs= -- Number representing time in seconds.

    =prec= -- Number of digits after the comma of seconds


*** Example
    #+BEGIN_SRC lisp
      (get-time 2753.3) ; => (0 45 53.30005)
    #+END_SRC
** get-val
   Function
   #+BEGIN_SRC lisp
     (get-val ref)
   #+END_SRC
   Return the value of /ref-object/.
*** Arguments
    =ref-object= -- An instance of [[ref-object][ref-object]].


*** See also
    - [[make-computed][make-computed]]
    - [[make-ref][make-ref]]
    - [[set-val][set-val]]
    - [[watch][watch]]
** *​gnuplot-header​*
   :PROPERTIES:
   :CUSTOM_ID: gnuplot-header
   :END:
   Variable

** *​gnuplot-options​*
   :PROPERTIES:
   :CUSTOM_ID: gnuplot-options
   :END:
   Variable

** *​gnuplot-program​*
   :PROPERTIES:
   :CUSTOM_ID: gnuplot-program
   :END:
   Variable

** group
   Function
   #+BEGIN_SRC lisp
     (group source n)
   #+END_SRC
   group elems of list into sublists of length n
** group-by
   Function
   #+BEGIN_SRC lisp
     (group-by list group-lengths)
   #+END_SRC
   Partition /list/ into sublists of lengths given by /group-lenghts/
   cyclically.
*** Arguments
    =list= -- The list to partition.

    =group-lenghts= -- A list of Positive Integers denoting the sequence
    of lengths of the partitions.


*** Example
    #+BEGIN_SRC lisp
      (group-by '(1 2 3 4 5 6 7 8 9 1 2 3 4 5 6 7 8 9 1 2 3 4 5 6) '(2 3 5))
      ;; => ((1 2) (3 4 5) (6 7 8 9 1) (2 3) (4 5 6) (7 8 9 1 2) (3 4) (5 6))
    #+END_SRC
** group-by-key
   Function
   #+BEGIN_SRC lisp
     (group-by-key source &key (test #'=) (key #'car))
   #+END_SRC
   Group elems of /source/ into sublists depending on /test/ and
   /key/. Source has to be sorted according to test!
** gui
   Function
   #+BEGIN_SRC lisp
     (gui)
   #+END_SRC
   Open the page at /<clamps-base-url>/ in a Browser.
*** See also
    - [[clamps-base-url][clamps-base-url]]
    - [[meters][meters]]
* H
** handle-midi-in
   Generic Function
   #+BEGIN_SRC lisp
     (handle-midi-in instance opcode d1 d2)
   #+END_SRC
** *​hanning1024​*
   :PROPERTIES:
   :CUSTOM_ID: hanning1024
   :END:
   Variable

   Incudine buffer of length 1024 containing a Hanning window.
*** Example
      #+BEGIN_SRC lisp
      (plot *hanning1024*)
      ;; => #<incudine:buffer :FRAMES 1024 :CHANNELS 1 :SR 44100.0>
      #+END_SRC
      
      #+attr_html: :width 50%
      #+CAPTION: *​hanning1024​* buffer
      [[./img/hanning-plot.svg]]
*** See also
    - [[#sine1024][*​​sine1024​​*]]
** highlight
   Generic Function
   #+BEGIN_SRC lisp
     (highlight clog-element value)
   #+END_SRC
* I-J
** id
   Generic Function
   #+BEGIN_SRC lisp
     (id object)
   #+END_SRC
   automatically generated reader method
** id-hash
   Generic Function
   #+BEGIN_SRC lisp
     (id-hash object)
   #+END_SRC
   automatically generated reader method
** idump
   Function
   #+BEGIN_SRC lisp
     (idump node)
   #+END_SRC
   Dump all active dsps of /node/ to the /incudine:*​​logger-stream​​*/
   output.
*** Arguments
    =node= -- The id of the node


*** Note
    If /(idump)/ doesn't create any output although dsps are running,
    reset the logger-stream using [[reset-logger-stream][reset-logger-stream]].
** *​in-refs​*
   :PROPERTIES:
   :CUSTOM_ID: in-refs
   :END:
   Variable

** index-list
   Function
   #+BEGIN_SRC lisp
     (index-list list &key (n 0))
   #+END_SRC
   Return /list/ with increasing indexes consed to the front of each
   element of list starting from /n/.
*** Arguments
    =list= -- List containing elements which get prepended indices.

    =n= -- Integer denoting starting index


*** Example
    #+BEGIN_SRC lisp
      (index-list '(a b c d e)) ; => ((0 . a) (1 . b) (2 . c) (3 . d) (4 . e))
    #+END_SRC
** index-seq
   Function
   #+BEGIN_SRC lisp
     (index-seq seq &optional (n 0))
   #+END_SRC
* K
** keynum->hz
   Function
   #+BEGIN_SRC lisp
     (keynum->hz keynum)
   #+END_SRC
   Convert VALUE dB to linear value.
* L
** let-default
   Macro
   #+BEGIN_SRC lisp
     (let-default ((sym test default)) &body body)
   #+END_SRC
** levelmeter
   Class

** levelmeter-full-gui
   Function
   #+BEGIN_SRC lisp
     (levelmeter-full-gui id gui-parent &key (#:group 300) (type :bus) refs (num 1) (audio-bus 0))
   #+END_SRC
** levelmeter-gui
   Function
   #+BEGIN_SRC lisp
     (levelmeter-gui id gui-parent &key (#:group 300) (type :bus) refs (num 1) (audio-bus 0))
   #+END_SRC
** lin-n
   Function
   #+BEGIN_SRC lisp
     (lin-n val min max)
   #+END_SRC
   Return the reverse linear interpolation for a value in the range
   /[min..max]/ as a normalized float value.
*** Arguments
    =x= -- An input value in the range /[min..max]/ to be interpolated.

    =min= -- The minimum value.

    =max= -- The maximum value.


*** Examples
    #+BEGIN_SRC lisp
      (lin-n 10 10 20) ; => 0.0
      
      (lin-n 15 10 20) ; => 0.5
      
      (lin-n 20 10 20) ; => 1.0
    #+END_SRC
*** See also
    - [[exp-n][exp-n]]
    - [[m-exp][m-exp]]
    - [[m-lin][m-lin]]
    - [[n-exp][n-exp]]
    - [[n-exp-dev][n-exp-dev]]
    - [[n-lin][n-lin]]
    - [[n-lin-dev][n-lin-dev]]
** line*
   Function
   #+BEGIN_SRC lisp
     (line* start end duration done-action &optional ugen-node)
   #+END_SRC
** lines->svg
   Function
   #+BEGIN_SRC lisp
     (lines->svg list svg-file &key color opacity (stroke-width 0.5))
   #+END_SRC
** list-dsps
   Function
   #+BEGIN_SRC lisp
     (list-dsps)
   #+END_SRC
   Return all running Incudine dsps registered with [[add-dsp][add-dsp]] in a
   list.
*** See also
    - [[add-dsp][add-dsp]]
    - [[find-dsp][find-dsp]]
    - [[remove-dsp][remove-dsp]]
** list-sfz-presets
   Function
   #+BEGIN_SRC lisp
     (list-sfz-presets &key (loaded nil))
   #+END_SRC
   Return a sorted list of all sfz preset names.
*** Arguments
    =:loaded= -- Boolean to indicate whether only the preset names of
    loaded presets should be returned. If /nil/ all registered preset
    names are returned.


** load-sfz-preset
   Function
   #+BEGIN_SRC lisp
     (load-sfz-preset file name &key force (play-fn #'play-sfz-loop))
   #+END_SRC
   Load a sfz file into a preset with the id name. In case this preset
   already exists, the old one will only be overwritten if force is
   set to t. This function normally doesn't need to be called
   explicitely. The preferred mechanism to deal with sfz presets is by
   using a combination of [[add-sfz-preset][add-sfz-preset]] and [[ensure-sfz-preset][ensure-sfz-preset]].
*** Arguments
    =file= -- Path or filename of the sfz file to load

    =name= -- symbol to identify the preset (preferably a keyword, but
    any symbol works)

    =:force= -- Force loading of the preset even if it already exists.

    =:play-fn= -- The play-fn to use when playing a sound. Possible
    choices are:

    - [[play-sfz-loop][#'play-sfz-loop]]
    - [[play-sfz-one-shot][#'play-sfz-one-shot]]

*** Examples
    #+BEGIN_SRC lisp
      (load-sfz-preset "~/quicklisp/local-projects/clamps/packages/cl-sfz/snd/sfz/Flute-nv/000_Flute-nv.sfz" :flute-nv)
    #+END_SRC
*** See also
    - [[add-sfz-preset][add-sfz-preset]]
    - [[ensure-sfz-preset][ensure-sfz-preset]]
    - [[remove-sfz-preset][remove-sfz-preset]]
** lsample
   Structure

   Structure for a sample with two loop-points.
*** Note
    Normally the user shouldn't be dealing with a lsample struct
    directly. It is used by the /sfz/ and /poolevent/ classes and
    documented here for completeness and insight.
    
    A lsample contains the following slots, accessible using the functions
    /lsample-<slot-name>/:
    
    =filename= -- Filename of the sample source.
    
    =buffer= -- Buffer of the sample data.
    
    =play-fn= -- Function for playing the lsample, defaults to /#'play-lsample-oneshot/.
    
    =keynum= -- Double Float denoting original keynum of the recorded sample.
    
    =loopstart= -- Double Float denoting the loop start for loop playback, dafaulting to /+​sample-zero​+/.
    
    =loopend= -- Double Float denoting the loop start for loop playback, dafaulting to /+​sample-zero​+/.
    
    =amp= -- Amplitude of recorded sample in dB, defaulting to /+​sample-Zero​+/.
    
    =id= -- Buffer ID of sample-buffer, defaulting to /nil/.
    
*** See also
    - [[sfz][sfz]]
* M
** m-exp
   Function
   #+BEGIN_SRC lisp
     (m-exp x min max)
   #+END_SRC
   Return the exponential interpolation for a MIDI value in the range
   /[min..max]/ as a float value. The min and max values have to be
   positive.
*** Arguments
    =x= -- An input value in the range /[0..127]/ to be interpolated.

    =min= -- The output value for /x = 0/.

    =max= -- The output value for /x = 127/.


*** Examples
    #+BEGIN_SRC lisp
      #+BEGIN_SRC lisp
      (m-exp 0 1 100) ; => 1.0 (100.0%)
      
      (m-exp 64 1 100) ; => 10.18296
      
      (m-exp 127 1 100) ; => 100.0
      #+END_SRC
    #+END_SRC
*** See also
    - [[exp-n][exp-n]]
    - [[lin-n][lin-n]]
    - [[m-lin][m-lin]]
    - [[n-exp][n-exp]]
    - [[n-exp-dev][n-exp-dev]]
    - [[n-lin][n-lin]]
    - [[n-lin-dev][n-lin-dev]]
** m-exp-dev
   Function
   #+BEGIN_SRC lisp
     (m-exp-dev x max)
   #+END_SRC
   return a random deviation factor, the deviation being exponentially
   interpolated between 1 for x=0 and [1/max..max] for x=127.
** m-exp-fn
   Function
   #+BEGIN_SRC lisp
     (m-exp-fn min max)
   #+END_SRC
   exp interpolation for midivalues (x = [0..127])
** m-exp-rd-fn
   Function
   #+BEGIN_SRC lisp
     (m-exp-rd-fn min max)
   #+END_SRC
   rounded exp interpolation for midivalues (x = [0..127])
** m-exp-rd-rev-fn
   Function
   #+BEGIN_SRC lisp
     (m-exp-rd-rev-fn min max)
   #+END_SRC
** m-exp-rev-fn
   Function
   #+BEGIN_SRC lisp
     (m-exp-rev-fn min max)
   #+END_SRC
   exp reverse interpolation fn for midivalues (x = [0..127])
** m-exp-zero
   Function
   #+BEGIN_SRC lisp
     (m-exp-zero x min max)
   #+END_SRC
   exp interpolation for midivalues (x = [0..127]) with 0 for x = 0
** m-exp-zero-fn
   Function
   #+BEGIN_SRC lisp
     (m-exp-zero-fn min max)
   #+END_SRC
   exp interpolation for midivalues (x = [0..127])
** m-exp-zero-rev-fn
   Function
   #+BEGIN_SRC lisp
     (m-exp-zero-rev-fn min max)
   #+END_SRC
   exp reverse interpolation fn returning midivalues [0..127]
** m-lin
   Function
   #+BEGIN_SRC lisp
     (m-lin x min max)
   #+END_SRC
   Return the linear interpolation for a MIDI value in the range
   /[min..max]/ as a float value.
*** Arguments
    =x= -- An input value in the range /[0..127]/ to be interpolated.

    =min= -- The output value for /x = 0/.

    =max= -- The output value for /x = 127/.


*** Examples
    #+BEGIN_SRC lisp
      #+BEGIN_SRC lisp
      (m-lin 0 10 20) ; => 10.0
      
      (m-lin 64 10 20) ; => 15.039371
      
      (m-lin 127 10 20)  ; => 20.0
      #+END_SRC
    #+END_SRC
*** See also
    - [[exp-n][exp-n]]
    - [[lin-n][lin-n]]
    - [[m-exp][m-exp]]
    - [[n-exp][n-exp]]
    - [[n-exp-dev][n-exp-dev]]
    - [[n-lin][n-lin]]
    - [[n-lin-dev][n-lin-dev]]
** m-lin-dev
   Function
   #+BEGIN_SRC lisp
     (m-lin-dev x max)
   #+END_SRC
   return a random deviation offset, the deviation being linearly
   interpolated between 0 for x=0 and [-max..max] for x=127.
** m-lin-fn
   Function
   #+BEGIN_SRC lisp
     (m-lin-fn min max)
   #+END_SRC
   linear interpolation for midivalues (x = [0..127])
** m-lin-rd-fn
   Function
   #+BEGIN_SRC lisp
     (m-lin-rd-fn min max)
   #+END_SRC
   rounded linear interpolation for midivalues (x = [0..127])
** m-lin-rd-rev-fn
   Function
   #+BEGIN_SRC lisp
     (m-lin-rd-rev-fn min max)
   #+END_SRC
** m-lin-rev-fn
   Function
   #+BEGIN_SRC lisp
     (m-lin-rev-fn min max)
   #+END_SRC
** make-adjustable-string
   Function
   #+BEGIN_SRC lisp
     (make-adjustable-string)
   #+END_SRC
** make-bang
   Function
   #+BEGIN_SRC lisp
     (make-bang &optional fn)
   #+END_SRC
** make-cm-line
   Function
   #+BEGIN_SRC lisp
     (make-cm-line args)
   #+END_SRC
   wrapper function for mapping.
** make-computed
   Function
   #+BEGIN_SRC lisp
     (make-computed fn &optional (setter nil))
   #+END_SRC
   Return a [[ref-object][ref-object]] which recalculates and sets its value using
   /fn/ whenever a ref-object accessed with [[get-val][get-val]] in the body of
   /fn/ is changed.
   
   Refer to [[clamps:Defining relations][Defining relations]] in the Clamps documentation for
   examples.
*** Arguments
    =fn= -- Function of no arguments to call whenever a value accessed
    using [[get-val][get-val]] in the body of the function is changed.

    =setter= -- Function of one argument called with the value of the
    ref-object returned by /make-computed/ whenever it changes.


*** See also
    - [[get-val][get-val]]
    - [[make-ref][make-ref]]
    - [[set-val][set-val]]
    - [[watch][watch]]
** make-keyword
   Function
   #+BEGIN_SRC lisp
     (make-keyword name)
   #+END_SRC
   Return a keyword from /name/.
*** Arguments
    =name= -- String to intern


*** Example
    #+BEGIN_SRC lisp
      (make-keyword "Hello") => :hello
    #+END_SRC
** make-lsample
   Function
   #+BEGIN_SRC lisp
     (make-lsample &key ((:filename #:filename) nil) ((:buffer #:buffer) nil) ((:play-fn #:play-fn) #'play-lsample-oneshot*) ((:keynum #:keynum) +sample-zero+) ((:loopstart #:loopstart) +sample-zero+) ((:amp #:amp) (sample 0)) ((:loopend #:loopend) +sample-zero+) ((:id #:id) nil))
   #+END_SRC
** make-oasr
   Function
   #+BEGIN_SRC lisp
     (make-oasr suswidth suspan sustain-level &key (curve -4) base restart-level (real-time-p (allow-rt-memory-p)))
   #+END_SRC
   Create and return a new ENVELOPE structure with ATTACK-TIME, SUSTAIN-LEVEL
   and RELEASE-TIME.
   
   The curvature CURVE defaults to -4.
** make-quantlist
   Function
   #+BEGIN_SRC lisp
     (make-quantlist vals)
   #+END_SRC
   Return the sorted list of quantization points in fractions of a beat
   [0..1] for a list of the beat division numbers to be considered,
   supplied in /vals/.
*** Arguments
    =vals= -- List of integer beat-divisions to be collected.


*** Examples
    #+BEGIN_SRC lisp
      (make-quantlist '(4)) ; => (0 1/4 1/2 3/4 1)
      
      (make-quantlist '(3 4)) ; => (0 1/4 1/3 1/2 2/3 3/4 1)
      
      (make-quantlist '(3 4 5)) ; => (0 1/5 1/4 1/3 2/5 1/2 3/5 2/3 3/4 4/5 1)
    #+END_SRC
*** See also
    - [[quantize-time][quantize-time]]
** make-ref
   Function
   #+BEGIN_SRC lisp
     (make-ref val &rest args)
   #+END_SRC
   Return an instance of [[ref-object][ref-object]] with initial value /val/.
*** Arguments
    =val= -- Initial value of the created instance. It can be of any
    type.

    =args= -- Optional args supplied to make-instance. They are used
    internally and are not intended to be used directly when working
    with /cl-refs/.


*** See also
    - [[get-val][get-val]]
    - [[make-computed][make-computed]]
    - [[set-val][set-val]]
    - [[watch][watch]]
** map-all-pairs
   Function
   #+BEGIN_SRC lisp
     (map-all-pairs return-type fn list)
   #+END_SRC
   Execute /fn/ on all possible pairs of two different elements of
   /list/. The pairs are given to fn in the order of appearance in the
   list. /return-type/ serves the same purpose as in #'map.
*** Arguments
    =return-type= -- A Sequence type or nil.

    =fn= -- Function of two arguments called on all pairs.

    =list= -- List containing all elements to which fn gets applied
    pairwise.


*** Example
    #+BEGIN_SRC lisp
      (map-all-pairs 'list #'list '(1 2 3 4 5))
      ;; => ((1 2) (1 3) (1 4) (1 5) (2 3) (2 4) (2 5) (3 4) (3 5) (4 5))
    #+END_SRC
** map-indexed
   Macro
   #+BEGIN_SRC lisp
     (map-indexed result-type fn &rest seqs)
   #+END_SRC
   Map /fn/ over /seqs/ with incrementing zero-based idx. The idx will
   get supplied as first arg to /fn/. /result-type/ serves the same
   purpose as in #'map.
*** Arguments
    =result-type= -- Result type to return. If nil, don't return a
    result.

    =fn= -- Function to map over sequences. Needs to accept /(+ 1
    (length seqs))/ arguments.

    =seqs= -- One or more sequences where mapping gets applied, similar
    to map.


*** Example
    #+BEGIN_SRC lisp
      (map-indexed 'list #'list '(a b c d e)  '(20 10 30 50 40))
      ;; => ((0 a 20) (1 b 10) (2 c 30) (3 d 50) (4 e 40))
    #+END_SRC
** map-params
   Macro
   #+BEGIN_SRC lisp
     (map-params syms values)
   #+END_SRC
** map-proplist
   Macro
   #+BEGIN_SRC lisp
     (map-proplist fn proplist)
   #+END_SRC
   Like mapcar but traversing a property list. /fn/ has to accept two
   values, the key and the value of each property in the proplist.
*** Arguments
    =fn= -- Function to apply to all entries of the property list.

    =proplist= -- Property list to traverse.


*** Example
    #+BEGIN_SRC lisp
      (map-proplist #'list '(:a 2 :b 5 :c 4)) ; => ((:a 2) (:b 5) (:c 4))
    #+END_SRC
*** See also
    - [[delete-props][delete-props]]
    - [[do-proplist][do-proplist]]
    - [[do-proplist/collecting][do-proplist/collecting]]
    - [[get-prop][get-prop]]
    - [[get-props-list][get-props-list]]
    - [[with-props][with-props]]
** map-tree
   Function
   #+BEGIN_SRC lisp
     (map-tree fn tree &key (test (lambda (elem) (not (consp elem)))))
   #+END_SRC
   Map function recursively and non-destructively on all leaf nodes of
   given tree (represented as a nested list). Leaf nodes are determind by
   applying #'test on the list containing them. If /test/ returns /t/,
   the node is considered to be a leaf node. Return the modified tree as
   a new structure.
*** Arguments
    =fn= -- Function to call on the leaf nodes.

    =tree= -- List to traverse, possibly nested


*** Examples
    #+BEGIN_SRC lisp
      (map-tree #'print '(1 (2 7 (8 9 ((17 15 (14)) 5 (3))))))
      ;; => (1 (2 7 (8 9 ((17 15 (14)) 5 (3)))))
      ;; output in the REPL:
      1 
      2 
      7 
      8 
      9 
      17 
      15 
      14 
      5 
      3 
      
      (map-tree (lambda (x) (+ x 100)) '(1 (2 7 (8 9 ((17 15 (14)) 5 (3))))))
      ;; => (101 (102 107 (108 109 ((117 115 (114)) 105 (103)))))
    #+END_SRC
** mappend
   Function
   #+BEGIN_SRC lisp
     (mappend fn list)
   #+END_SRC
   Append the results of calling fn on each element of list.
     Like mapcon, but uses append instead of nconc. Copied from Peter
     Norvig's AIP book.
** mapply
   Macro
   #+BEGIN_SRC lisp
     (mapply fn liste)
   #+END_SRC
** master-amp-bus-levelmeter-gui
   Function
   #+BEGIN_SRC lisp
     (master-amp-bus-levelmeter-gui id gui-parent &key (#:group 300) (audio-bus 0) (out-chan 0) (num-channels 1) (amp (make-ref 1)) (amp-slider (make-ref (amp->db-slider 1))) meter-refs (meter-display (make-ref :post)) (bus-name "") (min -40) (max 12) nb-ampdb)
   #+END_SRC
** master-amp-meter-bus
   Class

** master-amp-out-levelmeter-gui
   Function
   #+BEGIN_SRC lisp
     (master-amp-out-levelmeter-gui id gui-parent &key (#:group 300) (out-chan 0) (num-channels 1) (amp (make-ref 1)) (amp-slider (make-ref (amp->db-slider 1))) meter-refs (meter-display (make-ref :post)) (bus-name "") (min -40) (max 12) nb-ampdb)
   #+END_SRC
** master-bus-levelmeter-gui
   Function
   #+BEGIN_SRC lisp
     (master-bus-levelmeter-gui id gui-parent &key (#:group 300) refs (num 1) (audio-bus 0) (channel-offset 0) (create-bus t) (bus-name ""))
   #+END_SRC
   audio bus based levelmeter (group 300) routing NUM audio buses
   starting at AUDIO-BUS to audio-out CHANNEL-OFFSET. If CREATE-BUS is
   nil just create the levelmeter.
** memorize-random-state
   Function
   #+BEGIN_SRC lisp
     (memorize-random-state)
   #+END_SRC
** meters
   Function
   #+BEGIN_SRC lisp
     (meters)
   #+END_SRC
   Open the levelmeter page at /<clamps-base-url>/meters/ in a
   Browser.
*** See also
    - [[clamps-base-url][clamps-base-url]]
    - [[gui][gui]]
** *​midi-cc-fns​*
   :PROPERTIES:
   :CUSTOM_ID: midi-cc-fns
   :END:
   Variable

** *​midi-cc-state​*
   :PROPERTIES:
   :CUSTOM_ID: midi-cc-state
   :END:
   Variable

** midi-controller
   Class

   Generic class for midi controllers. An instance should get
   initialized with [[add-midi-controller][add-midi-controller]] and removed with
   [[remove-midi-controller][remove-midi-controller]], using its id as argument in order to close
   the gui and remove its handler functions from the midi controller
   registry.
** midi-controller
   Generic Function
   #+BEGIN_SRC lisp
     (midi-controller object)
   #+END_SRC
   automatically generated reader method
** *​midi-debug​*
   :PROPERTIES:
   :CUSTOM_ID: midi-debug
   :END:
   Variable

** midi-input
   Generic Function
   #+BEGIN_SRC lisp
     (midi-input object)
   #+END_SRC
   automatically generated reader method
** midi-output
   Generic Function
   #+BEGIN_SRC lisp
     (midi-output object)
   #+END_SRC
   automatically generated reader method
** mtof
   Function
   #+BEGIN_SRC lisp
     (mtof m &key (tuning-base 440))
   #+END_SRC
   Convert pitch in Midicts to frequency in Hz.
*** Arguments
    =midi-value= -- Pitch in Midicents.

    =:tuning-base= -- Frequency of A4 in Hz.


*** Examples
    #+BEGIN_SRC lisp
      (mtof 69) ; => 440
      
      (mtof 60.5) ; => 269.29178
      
      (mtof 69 :tuning-base 415) ; => 415
    #+END_SRC
*** See also
    - [[ftom][ftom]]
** mton
   Function
   #+BEGIN_SRC lisp
     (mton m)
   #+END_SRC
   Return normalized value mapped from MIDI value m in the range
   [0..127] as a single float.
*** Arguments
    =m= -- Number in the range [0..127]


*** Examples
    #+BEGIN_SRC lisp
      (mton 0) ; => 0
      
      (mton 13) ; => 0.10236221
      
      (mton 63.5) ; => 0.5
      
      (mton 127) ; => 1.0
    #+END_SRC
*** See also
    - [[ntom][ntom]]
** multf
   Macro
   #+BEGIN_SRC lisp
     (multf #:place &optional (number 1))
   #+END_SRC
   Like incf but multiplying instead of adding.
*** Arguments
    =place= -- A setfable place.

    =number= -- Number indicating the multiplication factor.


*** Examples
    #+BEGIN_SRC lisp
      (defvar *test* 2) ; => *test*
      
      (multf *test* 3) ; => 6
      
      *test*  ; => 6
    #+END_SRC
** mysubseq
   Function
   #+BEGIN_SRC lisp
     (mysubseq seq start &optional end)
   #+END_SRC
   Like subseq, but allowing negative values for end, indicating the
   number of elems before the end.
*** Arguments
    =seq= -- A Common Lisp Sequence.

    =start= -- Non Negative Integer denoting starting index of seq.

    =end= -- Integer denoting last index of seq. If negative, count from
    end.


*** Example
    #+BEGIN_SRC lisp
      (mysubseq '(a b c d e f g) 0 3) ; => (a b c)
      
      (mysubseq '(a b c d e f g) 0 -2) ; => (a b c d e)
    #+END_SRC
* N
** n-apply
   Function
   #+BEGIN_SRC lisp
     (n-apply n fn &key (initial-value '()) (collect nil))
   #+END_SRC
   call fn n times accumulating the results in acc. fn should accept two
   values, the current n and the accumulated results of previous
   calls. If collect is t return all results in a list.
** n-exp
   Function
   #+BEGIN_SRC lisp
     (n-exp x min max)
   #+END_SRC
   Return the exponential interpolation for a normalized value in the
   range /[min..max]/ as a float value.
*** Arguments
    =x= -- An input value in the range /[0..1]/ to be interpolated.

    =min= -- The output value for /x = 0/.

    =max= -- The output value for /x = 1/.


*** Examples
    #+BEGIN_SRC lisp
      #+BEGIN_SRC lisp
      (n-exp 0 1 100) ; => 1.0
      
      (n-exp 0.5 1 100) ; => 10.0
      
      (n-exp 1 1 100) ; => 100.0
      #+END_SRC
    #+END_SRC
*** See also
    - [[exp-n][exp-n]]
    - [[lin-n][lin-n]]
    - [[m-exp][m-exp]]
    - [[m-lin][m-lin]]
    - [[n-exp-dev][n-exp-dev]]
    - [[n-lin][n-lin]]
    - [[n-lin-dev][n-lin-dev]]
** n-exp-dev
   Function
   #+BEGIN_SRC lisp
     (n-exp-dev x max)
   #+END_SRC
   Return a random deviation factor, the deviation being exponentially
   interpolated between /1/ for /x = 0/ and /[1/max..max]/ for /x = 1/.
*** Arguments
    =x= -- An input value in the range /[0..1]/ to be interpolated.

    =max= -- The maximum deviation factor for /x = 1/;


*** Examples
    #+BEGIN_SRC lisp
      #+BEGIN_SRC lisp
      (n-exp-dev 0 4) ; => 1.0
      
      (n-exp-dev 0.5 4) ; a random value exponentially distributed in the range [0.5..2.0]
      
      (n-exp-dev 1 4) ; a random value exponentially distributed in the range [0.25..4.0]
      #+END_SRC
    #+END_SRC
*** See also
    - [[exp-n][exp-n]]
    - [[lin-n][lin-n]]
    - [[m-exp][m-exp]]
    - [[m-lin][m-lin]]
    - [[n-exp][n-exp]]
    - [[n-lin][n-lin]]
    - [[n-lin-dev][n-lin-dev]]
** n-exp-fn
   Function
   #+BEGIN_SRC lisp
     (n-exp-fn min max)
   #+END_SRC
   exponential interpolation for normalized x.
** n-exp-rev-fn
   Function
   #+BEGIN_SRC lisp
     (n-exp-rev-fn min max)
   #+END_SRC
   reverse of exponential interpolation for normalized x.
** n-exp-zero
   Function
   #+BEGIN_SRC lisp
     (n-exp-zero x min max)
   #+END_SRC
   exp interpolation for normalized values (x = [0..1]) with 0 for x = 0
** n-lin
   Function
   #+BEGIN_SRC lisp
     (n-lin x min max)
   #+END_SRC
   Return the linear interpolation for a normalized value in the range
   /[min..max]/ as a float value.
*** Arguments
    =x= -- An input value in the range /[0..1]/ to be interpolated.

    =min= -- The output value for /x = 0/.

    =max= -- The output value for /x = 1/.


*** Examples
    #+BEGIN_SRC lisp
      #+BEGIN_SRC lisp
      (n-lin 0 10 20) ; => 10.0
      
      (n-lin 0.5 10 20) ; => 15.0
      
      (n-lin 1 10 20)  ; => 20.0
      #+END_SRC
    #+END_SRC
*** See also
    - [[exp-n][exp-n]]
    - [[lin-n][lin-n]]
    - [[m-exp][m-exp]]
    - [[m-lin][m-lin]]
    - [[n-exp][n-exp]]
    - [[n-exp-dev][n-exp-dev]]
    - [[n-lin-dev][n-lin-dev]]
** n-lin-dev
   Function
   #+BEGIN_SRC lisp
     (n-lin-dev x max)
   #+END_SRC
   Return a random deviation value, the deviation being linearly
   interpolated between /0/ for /x = 0/ and /[-max..max]/ for /x = 1/.
*** Arguments
    =x= -- An input value in the range /[0..1]/ to be interpolated.

    =max= -- The maximum deviation value for /x = 1/;


*** Examples
    #+BEGIN_SRC lisp
      #+BEGIN_SRC lisp
      (n-lin-dev 0 4) ; => 0
      
      (n-lin-dev 0.5 4) ; a random value linearly distributed in the range [-2.0..2.0]
      
      (n-lin-dev 1 4) ; a random value linearly distributed in the range [-4.0..4.0]
      #+END_SRC
    #+END_SRC
*** See also
    - [[exp-n][exp-n]]
    - [[lin-n][lin-n]]
    - [[m-exp][m-exp]]
    - [[m-lin][m-lin]]
    - [[n-exp][n-exp]]
    - [[n-exp-dev][n-exp-dev]]
    - [[n-lin][n-lin]]
** n-lin-fn
   Function
   #+BEGIN_SRC lisp
     (n-lin-fn min max)
   #+END_SRC
   linear interpolation for normalized x.
** n-lin-rev-fn
   Function
   #+BEGIN_SRC lisp
     (n-lin-rev-fn min max)
   #+END_SRC
   reverse of linear interpolation for normalized x.
** named-amp-bus
   Class

** named-bus
   Class

** nanoktl2-midi
   Class

   Class for a Nanoktl2 midi controller.
** nanoktl2-preset-gui
   Function
   #+BEGIN_SRC lisp
     (nanoktl2-preset-gui #:id container &key (chan 5))
   #+END_SRC
** nanoktl2-preset-midi
   Class

** new-id
   Function
   #+BEGIN_SRC lisp
     (new-id svg-file id-type)
   #+END_SRC
** node-free-unprotected
   Function
   #+BEGIN_SRC lisp
     (node-free-unprotected)
   #+END_SRC
   Free all Incudine nodes of /group 200/. For details of the function of
   this group refer to section
   [[clamps:General Incudine Setup][General Incudine Setup]] in Clamps Packages.
*** See also
    - [[rts-hush][rts-hush]]
** node-group
   Generic Function
   #+BEGIN_SRC lisp
     (node-group object)
   #+END_SRC
   Accessor for the Incudine node-group slot of dsp /object/.
*** See also
    - [[cuda-dsp][cuda-dsp]]
** ntom
   Function
   #+BEGIN_SRC lisp
     (ntom n)
   #+END_SRC
   Return rounded MIDI value mapped from normalized n in the range
   [0..1].
*** Arguments
    =n= -- Number in the range [0..1]


*** Examples
    #+BEGIN_SRC lisp
      (ntom 0) ; => 0
      
      (ntom 0.1) ; => 13
      
      (ntom 0.5) ; => 64
      
      (ntom 1) ; => 127
    #+END_SRC
*** See also
    - [[mton][mton]]
* O
** of-buffer-load
   Function
   #+BEGIN_SRC lisp
     (of-buffer-load file &key (path *sfile-path*))
   #+END_SRC
   load and register buffer from file if not loaded already. Return
   buffer.
** on-deps-update
   Macro
   #+BEGIN_SRC lisp
     (on-deps-update &rest body)
   #+END_SRC
   return body if *​update-deps​* is non-nil, otherwise return nil.
** osc-midi-write-short
   Function
   #+BEGIN_SRC lisp
     (osc-midi-write-short stream st d1 d2)
   #+END_SRC
** *​out-refs​*
   :PROPERTIES:
   :CUSTOM_ID: out-refs
   :END:
   Variable

** out-stream-open?
   Function
   #+BEGIN_SRC lisp
     (out-stream-open? s)
   #+END_SRC
* P
** partition-seq
   Function
   #+BEGIN_SRC lisp
     (partition-seq seq pred)
   #+END_SRC
   Partition /seq/ into sublists based on a predicate called on successive
   elements. /pred/ is a function of two args, an element of the seq and
   its successor. If pred returns non-nil, a new subseq is started after
   the current element. The result contains all elements of the original
   seq in orginal order.
*** Example
    #+BEGIN_SRC lisp
      (partition-seq '(1 2 4 5 6 8 9) #'(lambda (x y) (> (- y x) 1))) 
      ;; => ((1 2) (4 5 6) (8 9))
      
      (partition-seq '(1 2 4 5 6 8 9) #'(lambda (x y) t)) 
      ;; => ((1) (2) (4) (5) (6) (8) (9))
    #+END_SRC
** path-find-file
   Function
   #+BEGIN_SRC lisp
     (path-find-file fname path)
   #+END_SRC
** permute
   Function
   #+BEGIN_SRC lisp
     (permute list permutation)
   #+END_SRC
   Return a permutation of /list/ according to the indexes in
   /permutation/.
*** Arguments
    =list= -- List of elements to be permuted.

    =permutation= -- List of permutation indexes.


*** Examples
    #+BEGIN_SRC lisp
      (permute '(1 2 3 4 5) '(3 1 4 2 0)) ; => (4 2 5 3 1)
    #+END_SRC
*** Note
    For a valid permutation the /permutation/ index list should contain
    all integer indexes of list starting from zero. In that case, length
    of /list/ is equal to the length of /permutation/. If it is shorter,
    an error occurs, if it is longer, not all elements of /list/ are
    returned.
** phasor*
   Function
   #+BEGIN_SRC lisp
     (phasor* freq #:init &optional ugen-node)
   #+END_SRC
** phasor-loop*
   Function
   #+BEGIN_SRC lisp
     (phasor-loop* rate start-pos loopstart loopend &optional ugen-node)
   #+END_SRC
** play-buffer*
   Function
   #+BEGIN_SRC lisp
     (play-buffer* &rest optional-keywords &aux (#:lambda-list '((buffer (incudine-missing-arg "buffer") (env (incudine-missing-arg "env")) (ampdb 0) (rate 1) (start 0) (end 0) (out 0) id head tail before after replace action stop-hook free-hook fade-time fade-curve))))
   #+END_SRC
** play-buffer-stretch*
   Function
   #+BEGIN_SRC lisp
     (play-buffer-stretch* &rest optional-keywords &aux (#:lambda-list '((buffer (incudine-missing-arg "buffer") (env (incudine-missing-arg "env")) (amp 0) (transp 0) (start 0) (end 0) (stretch 1) (wwidth 137) id head tail before after replace action stop-hook free-hook fade-time fade-curve))))
   #+END_SRC
** play-buffer-stretch
   Function
   #+BEGIN_SRC lisp
     (play-buffer-stretch &rest optional-keywords &aux (#:lambda-list '((buffer (incudine-missing-arg "buffer") (env (incudine-missing-arg "env")) (amp 0) (transp 0) (start 0) (end 0) (stretch 1) (wwidth 137) id head tail before after replace action stop-hook free-hook fade-time fade-curve))))
   #+END_SRC
** play-buffer-stretch-env-out
   Function
   #+BEGIN_SRC lisp
     (play-buffer-stretch-env-out &rest optional-keywords &aux (#:lambda-list '((buffer (incudine-missing-arg "buffer") (amp 0) (transp 0) (start 0) (end 0) (stretch 1) (wwidth 137) (attack 0) (release 0.01) (out 0) id head tail before after replace action stop-hook free-hook fade-time fade-curve))))
   #+END_SRC
** play-buffer-stretch-env-pan-out
   Function
   #+BEGIN_SRC lisp
     (play-buffer-stretch-env-pan-out &rest optional-keywords &aux (#:lambda-list '((buffer (incudine-missing-arg "buffer") (amp 0) (transp 0) (start 0) (end 0) (stretch 1) (wwidth 137) (attack 0) (release 0.01) (pan 0) (out1 0) (out2 1) id head tail before after replace action stop-hook free-hook fade-time fade-curve))))
   #+END_SRC
** play-buffer-stretch-env-pan-out*
   Function
   #+BEGIN_SRC lisp
     (play-buffer-stretch-env-pan-out* &rest optional-keywords &aux (#:lambda-list '((buffer (incudine-missing-arg "buffer") (env (incudine-missing-arg "env")) (amp 0) (transp 0) (start 0) (end 0) (stretch 1) (wwidth 137) (attack 0) (release 0.01) (pan 0) (out1 0) (out2 1) id head tail before after replace action stop-hook free-hook fade-time fade-curve))))
   #+END_SRC
** play-buffer-stretch-out
   Function
   #+BEGIN_SRC lisp
     (play-buffer-stretch-out &rest optional-keywords &aux (#:lambda-list '((buffer (incudine-missing-arg "buffer") (env (incudine-missing-arg "env")) (amp 0) (transp 0) (start 0) (end 0) (stretch 1) (wwidth 137) (out 0) id head tail before after replace action stop-hook free-hook fade-time fade-curve))))
   #+END_SRC
** play-lsample
   Function
   #+BEGIN_SRC lisp
     (play-lsample lsample pitch db dur &key (pan 0.5) (startpos 0))
   #+END_SRC
   play lsample with given pitch, amp and duration with loop.
** play-lsample*
   Function
   #+BEGIN_SRC lisp
     (play-lsample* &rest optional-keywords &aux (#:lambda-list '((buffer (incudine-missing-arg "buffer") (env (incudine-missing-arg "env")) (dur 1) (amp 0) (rate 1) (pan 0.5) (loopstart 0) (loopend 0) (startpos 0) (out1 0) (out2 1) id head tail before after replace action stop-hook free-hook fade-time fade-curve))))
   #+END_SRC
** play-sample*
   Function
   #+BEGIN_SRC lisp
     (play-sample* &rest optional-keywords &aux (#:lambda-list '((buffer (incudine-missing-arg "buffer") (env (incudine-missing-arg "env")) (dur 1) (amp 1) (rate 1) (pan 0.5) (startpos 0) (out1 0) (out2 1) id head tail before after replace action stop-hook free-hook fade-time fade-curve))))
   #+END_SRC
** play-sample
   Function
   #+BEGIN_SRC lisp
     (play-sample lsample pitch db dur &key (pan 0.5) (startpos 0))
   #+END_SRC
   play lsample once with given pitch, amp and duration.
** play-sfz
   Function
   #+BEGIN_SRC lisp
     (play-sfz pitch db dur &key (pan 0.5) (preset :flute-nv) (startpos 0) (out1 0) out2)
   #+END_SRC
   Play a sfz preset with stereo panning to incudine's audio outputs
   or a bus using the /play-fn/ of the sample to be played.
*** Arguments
    =pitch= -- Pitch in Midicent.

    =db= -- Amplitude in dB. /0/ corresponds to a scaling factor
    of /1/, /-100/ to a scaling factor of /0/.

    =dur= -- Duration in seconds.

    =:pan= -- Number in the range /[0..1]/ defining equal power panning
    between /out0/ and /out1/.

    =:preset= -- The name of a registered preset. If the preset hasn't
    been loaded it will get loaded before playback starts.

    =:startpos= -- The startposition in the sample in seconds.

    =:out1= -- Zero based index of the first outlet.

    =:out2= -- Zero based index of the second outlet. If not specified, /
    (mod (1+ out1) 8)/ will be used.


*** See also
    - [[play-sfz-loop][play-sfz-loop]]
    - [[play-sfz-one-shot][play-sfz-one-shot]]
** play-sfz-loop
   Function
   #+BEGIN_SRC lisp
     (play-sfz-loop pitch db dur &key (pan 0.5) (preset :flute-nv) (startpos 0) (out1 0) out2)
   #+END_SRC
   Play a sfz preset with stereo panning to incudine's audio outputs
   or a bus. Loop the sound according to the loop settings of the
   sample in the sfz file or loop the whole sound if not present. This
   function always uses loop playback regardless of the setting of
   /play-fn/ in the sample to be played.
*** Arguments
    =pitch= -- Pitch in Midicent.

    =db= -- Amplitude in dB. /0/ corresponds to a scaling factor
    of /1/, /-100/ to a scaling factor of /0/.

    =dur= -- Duration in seconds.

    =:pan= -- Number in the range /[0..1]/ defining equal power panning
    between /out0/ and /out1/.

    =:preset= -- The name of a registered preset. If the preset hasn't
    been loaded it will get loaded before playback starts.

    =:startpos= -- The startposition in the sample in seconds.

    =:out1= -- Zero based index of the first outlet.

    =:out2= -- Zero based index of the second outlet. If not specified, /
    (mod (1+ out1) 8)/ will be used.


*** See also
    - [[play-sfz][play-sfz]]
    - [[play-sfz-one-shot][play-sfz-one-shot]]
** play-sfz-one-shot
   Function
   #+BEGIN_SRC lisp
     (play-sfz-one-shot pitch db dur &key (pan 0.5) (preset :flute-nv) (startpos 0) (out1 0) out2)
   #+END_SRC
   Play a sfz preset with stereo panning to incudine's audio outputs
   or a bus once (regardless of the setting of /play-fn/ in the sample to
   be played). Playback stops after /dur/ seconds or at the end of the
   sample, if /dur/ is longer than the length of the sample.
*** Arguments
    =pitch= -- Pitch in Midicent.

    =db= -- Amplitude in dB. /0/ corresponds to a scaling factor
    of /1/, /-100/ to a scaling factor of /0/.

    =dur= -- Duration in seconds.

    =:pan= -- Number in the range /[0..1]/ defining equal power panning
    between /out0/ and /out1/.

    =:preset= -- The name of a registered preset. If the preset hasn't
    been loaded it will get loaded before playback starts.

    =:startpos= -- The startposition in the sample in seconds.

    =:out1= -- Zero based index of the first outlet.

    =:out2= -- Zero based index of the second outlet. If not specified, /
    (mod (1+ out1) 8)/ will be used.


*** See also
    - [[play-sfz][play-sfz]]
    - [[play-sfz-loop][play-sfz-loop]]
** plot
   Generic Function
   #+BEGIN_SRC lisp
     (plot data &rest args &key region header options grid x-axis num-values data-fn &allow-other-keys)
   #+END_SRC
   Plot input data given as an incudine envelope.
** plot-2d
   Function
   #+BEGIN_SRC lisp
     (plot-2d data &rest args &key region header options grid &allow-other-keys)
   #+END_SRC
** points->svg
   Function
   #+BEGIN_SRC lisp
     (points->svg list svg-file &key color opacity radius)
   #+END_SRC
** port-available-p
   Function
   #+BEGIN_SRC lisp
     (port-available-p portno)
   #+END_SRC
   Check if IP port is available on /localhost/ by issuing shell
   command. Only works on Unix with the /lsof/ program installed.
*** Arguments
    =portno= -- Integer in the range [0..65535]


** pulse
   Function
   #+BEGIN_SRC lisp
     (pulse midi-controller slot cc-num &key (pulse-freq 2) (initial-flash nil))
   #+END_SRC
   pulse the LED of <midi-controller> at <cc-num> with frequency
   <pulse-freq> as long as (get-val <slot>) equals 2. Starting with LED on or
   off is determined by <initial-flash>.
** pulse-off
   Generic Function
   #+BEGIN_SRC lisp
     (pulse-off clog-obj)
   #+END_SRC
** pulse-on
   Generic Function
   #+BEGIN_SRC lisp
     (pulse-on clog-obj &optional freq)
   #+END_SRC
** push-if
   Macro
   #+BEGIN_SRC lisp
     (push-if form list)
   #+END_SRC
   Push form to list if form evaluates to non-nil. Return the modified
   list or nil if form evaluates to nil.
*** Arguments
    =form= -- Form to be pushed to list.

    =list= -- List pushed into.


*** Examples
    #+BEGIN_SRC lisp
      (defvar *test* '()) ; => *test*
      
      (push-if 4 *test*) ; => (4)
      
      (push-if (eq 2 3) *test*) ; => nil
      
      *test* ; => (4)
    #+END_SRC
** pwd
   Function
   #+BEGIN_SRC lisp
     (pwd)
   #+END_SRC
   Return the current working directory as a pathname.
*** See also
    - [[cd][cd]]
* Q
** quantize-time
   Function
   #+BEGIN_SRC lisp
     (quantize-time val &optional (quantlist (make-quantlist '(3 4 5))))
   #+END_SRC
   Quantize the fractional part of /val/ to a quantization list
   /quantlist/ of possible quantization points in the range [0..1].
*** Arguments
    =val= -- The value to be quantized.

    =quantlist= -- Sorted list of possible quantization points in the
    range [0..1].


*** Examples
    #+BEGIN_SRC lisp
      (quantize-time 1/7 (make-quantlist '(3 4 5))) ; => 1/5
      
      (quantize-time 37/7 (make-quantlist '(3 4 5))) ; => 21/4
      
      (quantize-time 17/7 (make-quantlist '(3 4 5))) ; => 12/5
      
      (quantize-time 17/7 (make-quantlist '(3 4))) ; => 5/2 
    #+END_SRC
*** See also
    - [[make-quantlist][make-quantlist]]
* R
** r-elt
   Function
   #+BEGIN_SRC lisp
     (r-elt seq)
   #+END_SRC
   Return a random element of seq.
*** Arguments
    =seq= -- a sequence fulfilling the predicate /(typep seq 'sequence)/
    like a list or a vector.


*** Examples
    #+BEGIN_SRC lisp
      (r-elt #(1 2 3 4)) ; => 1, 2, 3 or 4
      
      (r-elt '(dog cat bird cow)) ; => dog, cat, bird or cow
    #+END_SRC
** r-exp
   Function
   #+BEGIN_SRC lisp
     (r-exp min max)
   #+END_SRC
   Random value between [min..max] with exponential distribution.
*** Arguments
    =min= -- Number indicationg the minimum value.

    =max= -- Number indicationg the maximum value.


*** See also
    - [[r-lin][r-lin]]
** r-exp-dev
   Function
   #+BEGIN_SRC lisp
     (r-exp-dev max)
   #+END_SRC
   return a random deviation factor, the deviation being exponentially
   interpolated between 1 for x=0 and [1/max..max] for x=1.
** r-getf
   Function
   #+BEGIN_SRC lisp
     (r-getf seq &rest props)
   #+END_SRC
   recursively traverse nested seq using props as idx. The values for
   props can be either numbers using #'elt or keywords/symbols (using
   getf).
** r-lin
   Function
   #+BEGIN_SRC lisp
     (r-lin min max)
   #+END_SRC
   Random value between [min..max] with linear distribution.
*** Arguments
    =min= -- Number indicationg the minimum value.

    =max= -- Number indicationg the maximum value.


*** See also
    - [[r-exp][r-exp]]
** random-elem
   Function
   #+BEGIN_SRC lisp
     (random-elem seq)
   #+END_SRC
   Return a random element of seq.
*** Arguments
    =seq= -- A Common Lisp Sequence.


** range
   Function
   #+BEGIN_SRC lisp
     (range &rest args)
   #+END_SRC
   Like clojure's range: Return a list of nums from start (inclusive) to
   end (exclusive) by step. Start and step are optional args defaulting
   to 0 and 1 respectively.
   
   Arities:
   
   (range end) 
   
   (range start end) 
   
   (range start end step) 
*** Examples
    #+BEGIN_SRC lisp
      (range 8) ; => (0 1 2 3 4 5 6 7) 
      
      (range 3 9) ; => (3 4 5 6 7 8) 
      
      (range 1 10 2) ; => (1 3 5 7 9)
    #+END_SRC
*** Note
    Unlike clozure's range function, this range function is not
    lazy: As a precaution (range) will return the empty list.
** recall-random-state
   Function
   #+BEGIN_SRC lisp
     (recall-random-state)
   #+END_SRC
** reducing
   Function
   #+BEGIN_SRC lisp
     (reducing fn seq &key key from-end (start 0) end (initial-value nil ivp))
   #+END_SRC
** ref-object
   Class
   #+BEGIN_SRC lisp
     (ref-object)
   #+END_SRC
       A /ref-object/ is a special class used in the /cl-refs/
      package. Its slots shouldn't be accessed or manipulated directly,
      but rather using the public functions of the cl-refs package listed
      below. For information how to use ref-objects refer to
      [[clamps:cl-refs][cl-refs]] in the Clamps Packages documentation.
*** See also
    - [[get-val][get-val]]
    - [[make-computed][make-computed]]
    - [[make-ref][make-ref]]
    - [[set-val][set-val]]
    - [[watch][watch]]
** regenerate-points
   Function
   #+BEGIN_SRC lisp
     (regenerate-points svg-file &key (fname #p"/tmp/test.svg") (xquantize t) (yquantize t))
   #+END_SRC
** remove-all-buffers
   Function
   #+BEGIN_SRC lisp
     (remove-all-buffers)
   #+END_SRC
   remove all buffers from registry.
** remove-all-dsps
   Function
   #+BEGIN_SRC lisp
     (remove-all-dsps)
   #+END_SRC
** remove-all-midi-controllers
   Function
   #+BEGIN_SRC lisp
     (remove-all-midi-controllers)
   #+END_SRC
   Unregister and delete all currently registered MIDI controller instances.
*** See also
    - [[add-midi-controller][add-midi-controller]]
    - [[find-controller][find-controller]]
    - [[remove-midi-controller][remove-midi-controller]]
** remove-buffer
   Function
   #+BEGIN_SRC lisp
     (remove-buffer buf)
   #+END_SRC
   remove buffer from registry.
** remove-dsp
   Function
   #+BEGIN_SRC lisp
     (remove-dsp id)
   #+END_SRC
   Remove a running Incudine dsp registered with [[add-dsp][add-dsp]].
*** Arguments
    =id= -- Keyword or Symbol identifying the dsp.


*** See also
    - [[add-dsp][add-dsp]]
    - [[find-dsp][find-dsp]]
    - [[list-dsps][list-dsps]]
** remove-midi-controller
   Function
   #+BEGIN_SRC lisp
     (remove-midi-controller #:id)
   #+END_SRC
   Unregister and delete the instance of a midi controller with ID /id/.
*** Arguments
    =id= -- Keyword or Symbol used as ID of the instance.


*** See also
    - [[add-midi-controller][add-midi-controller]]
    - [[find-controller][find-controller]]
    - [[remove-all-midi-controllers][remove-all-midi-controllers]]
** remove-sfz-preset
   Function
   #+BEGIN_SRC lisp
     (remove-sfz-preset name)
   #+END_SRC
   Remove the soundfile map associated with name. This is the opposite of [[load-sfz-preset][load-sfz-preset]].
*** Arguments
    =name= -- Keyword or symbol of the registered preset.


*** Note
    The soundfile buffers of the samples used in the sfz description
    and the association between the preset name and the sfz file are
    *​not​* removed! Only the association between the preset name, the
    keynums and the buffers are removed.
    
*** See also
    - [[load-sfz-preset][load-sfz-preset]]
    - [[get-sfz-preset][get-sfz-preset]]
** repeat
   Function
   #+BEGIN_SRC lisp
     (repeat n elem)
   #+END_SRC
   return a list with n occurences of elem. All occurences of elem are
   #'eq to each other.
*** Arguments
    =n= -- Integer indicationg the number of iterations

    =elem= -- Any Lisp Object to be repeated.


*** Examples
    #+BEGIN_SRC lisp
      (repeat 10 5) ;-> (5 5 5 5 5 5 5 5 5 5)
    #+END_SRC
** repeat-format
   Macro
   #+BEGIN_SRC lisp
     (repeat-format stream expr num)
   #+END_SRC
   format /expr/ /num/ times to /stream/
*** Arguments
    =stream= -- Output stream as in format.

    =expr= -- Expression to format repeatedly.

    =num= -- Integer number of repetitions.


*** Examples
    #+BEGIN_SRC lisp
      (repeat-format nil "la" 10) ; => "lalalalalalalalalala"
    #+END_SRC
** repeated
   Function
   #+BEGIN_SRC lisp
     (repeated n fn)
   #+END_SRC
   Return a function which applies a given function /fn/ /n/ times onto
   itself. /fn/ must be a function of at least one argument which returns
   one argument. The return value of the function replaces the first
   argument in the next recursive call, leaving all other arguments as
   they were.
*** Arguments
    =n= -- Integer number of repetitions.

    =fn= -- Function to be applied to itself.


*** Examples
    #+BEGIN_SRC lisp
      (funcall (repeated 4 (lambda (x) (* x 2))) 1)  ; => 16
      
      (funcall (repeated 4 (lambda (x) (* x 2))) 3) ; => 48
    #+END_SRC
*** See also
    - [[do-repeated][do-repeated]]
** reset-logger-stream
   Function
   #+BEGIN_SRC lisp
     (reset-logger-stream)
   #+END_SRC
   Resets /incudine:*​logger-stream​*/ to /*​​error-output​​*/ Call this
   function, if calls to /incudine.util:msg/ don't produce any output in
   the REPL.
*** Note
    This function needs to be called if /Clamps/ is started from a Lisp
    Image.
** restore-envs
   Function
   #+BEGIN_SRC lisp
     (restore-envs)
   #+END_SRC
** restore-tables
   Function
   #+BEGIN_SRC lisp
     (restore-tables)
   #+END_SRC
** reverse-all
   Function
   #+BEGIN_SRC lisp
     (reverse-all list)
   #+END_SRC
   Recursively reverse list and all its sublists.
*** Arguments
    =list= -- The list to recursively reverse.


*** Example
    #+BEGIN_SRC lisp
      (reverse-all '(1 (2 3) (4 (5 (6 7) 8) 9))) ; => ((9 (8 (7 6) 5) 4) (3 2) 1)
    #+END_SRC
** rfind
   Function
   #+BEGIN_SRC lisp
     (rfind item tree &key (test #'eql))
   #+END_SRC
   Find /item/ by traversing /tree/ recursively until /test/ called on
   /item/ and a tree element returns non-nil. Return item or nil if item
   is not found.
*** Arguments
    =item= -- Any Common Lisp Object.

    =tree= -- A list possibly nested.

    =:test= -- Function to test for equality between item and a tree
    element.


*** Example
    #+BEGIN_SRC lisp
      (rfind 'd '(a (b c (a d c) ((g d (e)) h f)))) ; => d 
    #+END_SRC
** rotate
   Function
   #+BEGIN_SRC lisp
     (rotate list &optional (num 1))
   #+END_SRC
   Rotate /list/ by /num/ elems (to the right). /num/ can be negative. If
   /num/ is larger than the list size it will wrap around as if the
   rotation was called recursively num times.
*** Arguments
    =list= -- List to rotate

    =num= -- Integer number of rotations.


*** Examples
    #+BEGIN_SRC lisp
      (rotate '(dog bird lion cat horse) 1) ; => (horse dog bird lion cat)
      (rotate '(dog bird lion cat horse) -1)  ; => (bird lion cat horse dog)
      
      (rotate '(dog bird lion cat horse) 4733) ; => (lion cat horse dog bird)
    #+END_SRC
** rts-hush
   Function
   #+BEGIN_SRC lisp
     (rts-hush)
   #+END_SRC
   Flush pending events from incudine's event queue, send out an all
   notes off message to all 16 channels of *​​midi-out1​​* and call
   [[node-free-unprotected][node-free-unprotected]].
* S
** set-basedir
   Function
   #+BEGIN_SRC lisp
     (set-basedir basedir)
   #+END_SRC
** set-bpm
   Function
   #+BEGIN_SRC lisp
     (set-bpm bpm)
   #+END_SRC
   Set the tempo in beats per minute for both, CM and Incudine.
*** Arguments
    =bpm= -- Number of beats per minute.


*** See also
    - [[set-tempo][set-tempo]]
** set-bpm
   Function
   #+BEGIN_SRC lisp
     (set-bpm bpm)
   #+END_SRC
   Set the tempo in beats per minute for both, CM and Incudine.
*** Arguments
    =bpm= -- Number of beats per minute.


*** See also
    - [[set-tempo][set-tempo]]
** set-marker
   Generic Function
   #+BEGIN_SRC lisp
     (set-marker object)
   #+END_SRC
   automatically generated reader method
** set-on-data
   Generic Function
   #+BEGIN_SRC lisp
     (set-on-data obj handler)
   #+END_SRC
** set-standard-pitch
   Function
   #+BEGIN_SRC lisp
     (set-standard-pitch freq)
   #+END_SRC
   Set the ∗​standard-pitch​∗ reference of Clamps to freq in Hz.
*** Arguments
    =freq= -- Frequency of A4 in Hz.


*** See also
    - [[#standard-pitch][*​​standard-pitch​​*]]
** set-tempo
   Function
   #+BEGIN_SRC lisp
     (set-tempo bpm)
   #+END_SRC
   Set the tempo in beats per minute for both, CM and Incudine.
*** Arguments
    =bpm= -- Number of beats per minute.


*** See also
    - [[set-bpm][set-bpm]]
** set-val
   Function
   #+BEGIN_SRC lisp
     (set-val ref value &key (force nil))
   #+END_SRC
   Set the value of ref-object /ref/ to /value/ if different than
   previous value. If /force/ is non-nil, set in any case. Return
   value.
*** Arguments
    =ref= -- An instance of [[ref-object][ref-object]]

    =value= -- Any value of any type to be set.

    =force= -- A boolean indicating to set the value even if it is eql
    to the previous value of the ref-object.


*** See also
    - [[get-val][get-val]]
    - [[make-computed][make-computed]]
    - [[make-ref][make-ref]]
    - [[watch][watch]]
** setf-default
   Macro
   #+BEGIN_SRC lisp
     (setf-default sym test default)
   #+END_SRC
** sfz
   Common Music Class
   #+BEGIN_SRC lisp
     (new sfz &key (keynum 60) (amplitude 0) (duration 1) (preset flute-nv) (play-fn nil) (pan 0.5) (startpos 0) (chan 100))
   #+END_SRC
   Create a sfz Event.
   
   sfz accepts the following slot initializations:
   
   =:time= The output time in seconds, initially unbound.
   
   =:keynum= Keynum in Midicents.
   
   =:amplitude= Amplitude in dB. /0/ corresponds to a scaling factor of /1/, /-100/ to a scaling factor of /0/.
   
   =:duration= Duration in seconds.
   
   =:preset= Keyword or symbol of a registered preset name.
   
   =:play-fn= The play function to be used for sample playback.
   
   =:pan= Number in the range /[0..1]/ defining equal power panning
   between the two outputs of the dsp on playback.
   
   =:startpos= The startposition in the sample in seconds.
   
   =:chan= The channel (layer) used in svg output.
*** Examples
    #+BEGIN_SRC lisp
        (new sfz)
        ;; => #i(sfz keynum 60 amplitude 1 duration 1 preset :flute-nv
        ;;           play-fn nil pan 0.5 startpos 0 chan 100)
      
        ;; the following code should send 1 second of a flute middle C sound
        ;; to the first two oulets of incudine:
      
        (output (new sfz)) ; => ; No value
      
        ;; => loading :flute-nv from ~/quicklisp/local-projects/clamps/extra/snd/sfz/Flute-nv/000_Flute-nv.sfz
        ;; ; No values
      
        (loop
           for idx below 200
          for x = (/ idx 199)
          for time = 0 then (+ time (n-exp (interp x 0 0  0.3 1  1 0) 0.01 0.1))
          do (sprout
              (new sfz
                :time time
                :keynum (+ 65.5 (random (n-lin (interp x 0 0 1 1) 1 5)))
                :duration (+ 0.5 (random 2.0))
                :amplitude (n-lin (interp x 0 0 0.8 0 1 1) -12 -24))))
      
        ;; => nil
    #+END_SRC
*** See also
    - [[dict:midi][midi]]
** sfz->lsample
   Function
   #+BEGIN_SRC lisp
     (sfz->lsample sfz-entry dir &key (play-fn #'play-sfz-loop))
   #+END_SRC
   Convert an entry of a sfz file into a lsample.
*** Arguments
    =sfz-entry= -- Instance of sfz class.

    =:play-fn= -- The play function to play the lsample. Possible
    options are:

    - #'play-sfz-loop
    - #'play-sfz-one-shot

*** See also
    - [[sfz][sfz]]
    - [[lsample][lsample]]
** sfz-get-range
   Function
   #+BEGIN_SRC lisp
     (sfz-get-range ref)
   #+END_SRC
   get the range of a sfz preset or a sfz file.
** sfz-preset-buffer
   Function
   #+BEGIN_SRC lisp
     (sfz-preset-buffer preset pitch)
   #+END_SRC
   return the buffer(s) of preset for pitch in a list.
** sfz-preset-file
   Function
   #+BEGIN_SRC lisp
     (sfz-preset-file preset)
   #+END_SRC
   Return the full path of /preset/.
*** Arguments
    =preset= -- Keyword or symbol of a registered sfz preset.


*** See also
    - [[add-sfz-preset][add-sfz-preset]]
** sfz-preset-loaded?
   Function
   #+BEGIN_SRC lisp
     (sfz-preset-loaded? preset)
   #+END_SRC
   Predicate to test if sfz preset is loaded.
*** Arguments
    =preset= -- Keyword or symbol of registered preset.


*** Examples
    #+BEGIN_SRC lisp
      #+BEGIN_SRC lisp
      ;;; Directly after Clamps startup:
      
      (sfz-preset-loaded? :flute-nv) ;; => nil
      
      (output (new sfz))
      ;; => loading :flute-nv from ~/quicklisp/local-procects/clamps/extra/snd/sfz/Flute-nv/000_Flute-nv.sfz
      ;; No values
      
      (sfz-preset-loaded? :flute-nv) ;; => t
      #+END_SRC
    #+END_SRC
*** See also
    - [[add-sfz-preset][add-sfz-preset]]
    - [[get-sfz-preset][get-sfz-preset]]
** *​sine1024​*
   :PROPERTIES:
   :CUSTOM_ID: sine1024
   :END:
   Variable

   Incudine buffer of length 1024 containing one period of a sine wave.
*** Example
      #+BEGIN_SRC lisp
      (plot *sine1024*)
      ;; => #<incudine:buffer :FRAMES 1024 :CHANNELS 1 :SR 44100.0>
      #+END_SRC
      
      #+attr_html: :width 50%
      #+CAPTION: *​sine1024​* buffer
      [[./img/sine-plot.svg]]
*** See also
    - [[#hanning1024][*​​hanning1024​​*]]
** slurp
   Function
   #+BEGIN_SRC lisp
     (slurp file)
   #+END_SRC
   Return contents of file as a list of all lines read individually by
   the lisp reader.
** slurp-string
   Function
   #+BEGIN_SRC lisp
     (slurp-string file)
   #+END_SRC
   Return contents of file as a string.
** spit
   Function
   #+BEGIN_SRC lisp
     (spit seq &key (outfile "/tmp/test.lisp"))
   #+END_SRC
   Print /seq/ to /outfile/, each element on a new line.
** splice
   Function
   #+BEGIN_SRC lisp
     (splice list &key (key #'first) (test #'eq))
   #+END_SRC
   Return a list of all sublists containing elements mutually satisfying
   the /test/ predicate.
*** Arguments
    =list= -- List to splice

    =key= -- Function applied to each element of list before testing.

    =test= -- Function to determine equality between two elements.


*** Examples
    #+BEGIN_SRC lisp
      (splice '((0 1) (4 7) (7 2) (0 3) (4 5) (1 3)))
       ; => (((0 1) (0 3)) ((4 7) (4 5)) ((7 2)) ((1 3)))
      
      (splice '((0 1) (4 7) (7 2) (0 3) (4 5) (1 7)) :key #'second)
       ; => (((0 1)) ((4 7) (1 7)) ((7 2)) ((0 3)) ((4 5)))
    #+END_SRC
** *​standard-pitch​*
   :PROPERTIES:
   :CUSTOM_ID: standard-pitch
   :END:
   Variable

   Tuning reference for /ftom/ and /mtof/ in Hz. Defaults to 440.
*** Important Note
    
    Don't set this value directly! Rather use the [[set-standard-pitch][set-standard-pitch]]
    function which changes the standard pitch reference for the entire
    /Clamps/ system.
    
*** See also
    - [[ftom][ftom]]
    - [[mtof][mtof]]
    - [[set-standard-pitch][set-standard-pitch]]
** start-doc-acceptor
   Function
   #+BEGIN_SRC lisp
     (start-doc-acceptor)
   #+END_SRC
   Start the doc acceptor for online documentation. This is done
   automatically on startup to make the clamps documentation
   accessible at the URL /https://localhost:8282/.
** start-gui
   Function
   #+BEGIN_SRC lisp
     (start-gui &key (port 54619) (gui-root (asdf:system-source-directory :clog-dsp-widgets)) (open t))
   #+END_SRC
** start-midi-engine
   Function
   #+BEGIN_SRC lisp
     (start-midi-engine)
   #+END_SRC
   open midi ports and start realtime thread.
** start-midi-receive
   Function
   #+BEGIN_SRC lisp
     (start-midi-receive input)
   #+END_SRC
   Start the clamps generic midi handler and all registered MIDI responders
   of input stream /input/.
*** Arguments
    =input= -- Input MIDI stream of type /<jackmidi:input-stream>/.


*** See also
    - [[stop-midi-receive][stop-midi-receive]]
** start-osc-midi-receive
   Function
   #+BEGIN_SRC lisp
     (start-osc-midi-receive local-midi-in &key (port 4711))
   #+END_SRC
   start osc on localhost:port and its receivers.
** stop-midi-receive
   Function
   #+BEGIN_SRC lisp
     (stop-midi-receive input)
   #+END_SRC
   Stop the clamps generic midi handler and remove all registered MIDI
   responders of input stream /input/.
*** Arguments
    =input= -- Input MIDI stream of type /<jackmidi:input-stream>/.


*** See also
    - [[start-midi-receive][start-midi-receive]]
** stop-osc-midi-receive
   Function
   #+BEGIN_SRC lisp
     (stop-osc-midi-receive &optional local-midi-in)
   #+END_SRC
** str-concat
   Function
   #+BEGIN_SRC lisp
     (str-concat &rest args)
   #+END_SRC
   concatenate strings.
*** Arguments
    =args= -- one or more strings to concatenate


*** Example
    #+BEGIN_SRC lisp
      (str-concat "Hello" " World") ; => "Hello World"
    #+END_SRC
** svg->browser
   Function
   #+BEGIN_SRC lisp
     (svg->browser svg-file &key (bar-lines 1) (staff-systems 1) (piano-roll 0) (scale 1) (timescale 1/32) (inverse 0))
   #+END_SRC
   Display =svg-file= in the SVG Player Gui, located at
   /<clamps-base-url>/svg-display/.
*** Arguments
    =svg-file= -- String naming the svg-file to display/play. The
    filename is interpreted relative to the /<clamps-gui-root>/svg/
    directory.


** svg->lines
   Function
   #+BEGIN_SRC lisp
     (svg->lines &key (infile #p"/tmp/test.svg") (timescale 1) (xquantize nil) (yquantize nil) (layer "events") group? layer?)
   #+END_SRC
   extract all line objects in the layer "Events" of svg infile.
   Also removes duplicates and flattens subgroups. Lines are property
   lists containing all svg attributes.
** svg->points
   Function
   #+BEGIN_SRC lisp
     (svg->points &key (infile #p"/tmp/test.svg") (timescale 1) (xquantize t) (yquantize t) (x-offset 0) (layer "punkte"))
   #+END_SRC
   extract all circle objects (points) in the layer "Punkte" of svg infile.
   Also removes duplicates and flattens subgroups. Points are simple
   two-element lists containing x and y coordinates. The y coordinate is
   supposed to be a midifloat value, x ist translated into secs/beats.
** svg-class
   Generic Function
   #+BEGIN_SRC lisp
     (svg-class object)
   #+END_SRC
   automatically generated reader method
** svg-clone
   Class

** svg-cm-line
   Class

** svg-collect-lines
   Function
   #+BEGIN_SRC lisp
     (svg-collect-lines layer parse-state &key (timescale 1) (x-offset 0) (xquantize nil) (yquantize nil) layer?)
   #+END_SRC
   return a list of svg-cm-line instances of layer with a given parse-state.
** svg-file
   Class

** svg-group
   Class

** svg-gui-path
   Function
   #+BEGIN_SRC lisp
     (svg-gui-path str)
   #+END_SRC
** svg-layer
   Class

** svg-line
   Class

** svg-point
   Class

** svg-rect
   Class

** svg-text
   Class

** system-version
   Function
   #+BEGIN_SRC lisp
     (system-version system-designator)
   #+END_SRC
   Return the version of an installed /asdf/ system or nil if not
   bound/existent.
*** Arguments
    =system-designator= -- A designator acceptable to /asdf:find-system/


*** Examples
    #+BEGIN_SRC lisp
      (system-version :cm) ; => "2.12.0"
    #+END_SRC
* T
** text-anchor
   Generic Function
   #+BEGIN_SRC lisp
     (text-anchor object)
   #+END_SRC
   automatically generated reader method
** toggle-slot
   Macro
   #+BEGIN_SRC lisp
     (toggle-slot slot)
   #+END_SRC
** transform
   Generic Function
   #+BEGIN_SRC lisp
     (transform object)
   #+END_SRC
   automatically generated reader method
** trigger
   Generic Function
   #+BEGIN_SRC lisp
     (trigger obj)
   #+END_SRC
* U
** ucopy
   Generic Function
   #+BEGIN_SRC lisp
     (ucopy sym)
   #+END_SRC
   Copy an instance of a class recursively.
** unwatch
   Generic Function
   #+BEGIN_SRC lisp
     (unwatch object)
   #+END_SRC
   automatically generated reader method
** update-all-controllers
   Function
   #+BEGIN_SRC lisp
     (update-all-controllers midi-in-port)
   #+END_SRC
** update-preset-buttons
   Function
   #+BEGIN_SRC lisp
     (update-preset-buttons controller)
   #+END_SRC
** update-state
   Generic Function
   #+BEGIN_SRC lisp
     (update-state instance)
   #+END_SRC
* V
** v-collect
   Macro
   #+BEGIN_SRC lisp
     (v-collect (v n &optional (tail '())) &rest body)
   #+END_SRC
   Return a list of /n/ elems prepended to tail by evaluating /body/ /n/
   times with the symbol /v/ bound to the iteration index in the lexical
   scope of form.
*** Arguments
    =v= -- Symbol used as variable name.

    =n= -- Integer indicating the number of iterations.

    =body= -- Function body being evaluated n times.


*** Examples
    #+BEGIN_SRC lisp
      (v-collect (n 10) (* n n)) ;-> (0 1 4 9 16 25 36 49 64 81)
    #+END_SRC
*** See also
    - [[call/collecting][call/collecting]]
* W-Y
** watch
   Function
   #+BEGIN_SRC lisp
     (watch fn)
   #+END_SRC
   Call /fn/ whenever a value accessed using [[get-val][get-val]] in the body of
   the function is changed.
   
   /watch/ returns a function to remove the relation, /watch/ has
   established. Refer to the chapter [[clamps:cl-refs][cl-refs]] in the Clamps
   Packages documentation for examples.
*** Arguments
    =fn= -- Function of no arguments to call


*** See also
    - [[get-val][get-val]]
    - [[make-computed][make-computed]]
    - [[make-ref][make-ref]]
    - [[set-val][set-val]]
** with-curr-dir
   Macro
   #+BEGIN_SRC lisp
     (with-curr-dir (dir) &body body)
   #+END_SRC
   set the cwd to dir in the body, return the result of body after
   resetting the cwd.
** with-exp-midi-fn
   Macro
   #+BEGIN_SRC lisp
     (with-exp-midi-fn (min max) &body body)
   #+END_SRC
   return closure with ipfn bound to an exponential interpolation of
   the input range 0..127 between min and max.
** with-file-stream
   Macro
   #+BEGIN_SRC lisp
     (with-file-stream (stream fname &key (direction :output) (if-exists :supersede)) &rest body)
   #+END_SRC
** with-gnuplot-instance
   Macro
   #+BEGIN_SRC lisp
     (with-gnuplot-instance (stream &rest args) &body body)
   #+END_SRC
   start an external gnuplot process with a data input stream open for the extent of body.
   
   stream is bound to gnuplot's input stream. Printing to it is
   equivalent to printing into a file read by gnuplot as a dataset with
   its plot command.
   
   args are arguments sent to #'launch-gnuplot. 
   
   Leaving the macro is equivalent to gnuplot reaching EOF when reading
   an external dataset.
** with-gui-update-off
   Macro
   #+BEGIN_SRC lisp
     (with-gui-update-off (instance) &body body)
   #+END_SRC
** with-lin-midi-fn
   Macro
   #+BEGIN_SRC lisp
     (with-lin-midi-fn (min max) &body body)
   #+END_SRC
   Return closure with ipfn bound to a linear interpolation of the
   input range 0..127 between min and max.
** with-props
   Macro
   #+BEGIN_SRC lisp
     (with-props vars proplist &body body)
   #+END_SRC
   Like with-slots but using a property list instead of a class
   instance. The properties in the /proplist/ to be used need to have a
   symbol or a keyword as a key. /vars/ is a list of symbols bound to the
   corresponding property values in the lexical scope of /body/. Each
   element of vars corresponds to a key in proplist either being the
   binding symbol itself or a keyword, derived by prepending a colon to
   the binding symbol.
*** Arguments
    =vars= -- List of symbols of the Properties to use in the lexical
    scope of body.

    =proplist= -- Property list containing bound properties.

    =body= -- The body in which the vars are bound.


*** Example
    #+BEGIN_SRC lisp
      (with-props (a b c) '(:a 1 :b 2 c 3)
        (list a b c))
      ;; => (1 2 3)
    #+END_SRC
*** See also
    - [[delete-props][delete-props]]
    - [[do-proplist][do-proplist]]
    - [[do-proplist/collecting][do-proplist/collecting]]
    - [[get-prop][get-prop]]
    - [[get-props-list][get-props-list]]
    - [[map-proplist][map-proplist]]
** with-shadowed-variable
   Macro
   #+BEGIN_SRC lisp
     (with-shadowed-variable (var) &rest body)
   #+END_SRC
   Shadow /var/ in the local scope of /body/. /var/ should be bound
   before entering /with-shadowed-variable/.
*** Arguments
    =var= -- Symbol of variable to shadow

    =body= -- Body for the scope of the shadowing.


*** Example
    #+BEGIN_SRC lisp
      (defvar *myvar* 2) ; => *myvar*
      
      (defun return-myvar ()
       *myvar*)
      
      (with-shadowed-variable (*myvar*)
        (setf *myvar* 10)
        (return-myvar))
      
      ;; => 10
      
      *myvar* ; => 2
    #+END_SRC
** with-svg-file
   Macro
   #+BEGIN_SRC lisp
     (with-svg-file (svg-file &rest keys) &body body)
   #+END_SRC
** with-unwatched
   Macro
   #+BEGIN_SRC lisp
     (with-unwatched bindings &body body)
   #+END_SRC
   all #'get-val forms contained in bindings are not watched.
* Z
** zoom
   Generic Function
   #+BEGIN_SRC lisp
     (zoom object)
   #+END_SRC
   automatically generated reader method
